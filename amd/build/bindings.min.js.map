{"version":3,"file":"bindings.min.js","sources":["../src/bindings.js"],"sourcesContent":["/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport jQuery from 'jquery';\nimport {evalInContext} from './util';\n\n/**\n * @param {*} value\n * @param {string | undefined} type\n * @returns {*}\n */\nexport const performCasting = function(value, type) {\n    if (!type || typeof value === type) {\n        return value;\n    }\n    switch (type) {\n        case (\"boolean\"):\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\n                value = true;\n            } else {\n                value = false;\n            }\n            break;\n        case (\"number\"):\n            try {\n                let parsed;\n                if ((value + '').indexOf(\".\") < 0) {\n                    parsed = parseInt(value);\n                } else {\n                    parsed = parseFloat(value);\n                }\n                if (!isNaN(parsed)) {\n                    value = parsed;\n                } else {\n                    value = 0;\n                    console.error(`Error parsing number ${value}`);\n                }\n            } catch (ex) {\n                value = 0;\n                console.error(`Error parsing number ${value}`);\n            }\n            break;\n        case (\"string\"):\n            if (typeof value === 'object') {\n                value = JSON.stringify(value);\n            } else {\n                value = value + \"\";\n            }\n            break;\n        default:\n            console.error(`Fail to cast ${value} to ${type}`);\n    }\n    return value;\n};\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n */\nconst xor = function(a, b) {\n    return !a !== !b;\n};\n\n/**\n * @param {string} str\n * @param {*} match\n * @param {string} replacement\n * @returns {string}\n */\nconst replaceStrPart = function(str, match, replacement) {\n    if (!match.indices) {\n        console.error(\"RegExp match does not include indices\");\n        return str;\n    }\n    const [a, b] = match.indices[1];\n    return str.substring(0, a) + replacement + str.substring(b);\n};\n\n/**\n * Replaces the first capturing group in regexExpr by replacement,\n * The remaining capturing groups are removed.\n * @param {string} regexExpr\n * @param {string} replacement\n * @returns {string}\n */\nconst getValueFromRegex = function(regexExpr, replacement) {\n    const reParser = /\\((?!\\?:).*?\\)/g;\n    let capturingGroupCount = 0;\n    return regexExpr.replace(reParser, () => {\n        capturingGroupCount++;\n        if (capturingGroupCount === 1) {\n            return replacement + '';\n        }\n        return \"\"; // Remove all other capturing groups\n    });\n};\n\n/**\n * @param {Element} el - The target element\n * @returns\n */\nconst bindingFactory = function(el) {\n    /** @this {Record<string, Function>} */\n    const methods = {\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasClass: (className, query, neg) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                // @ts-ignore\n                getValue: () => {\n                    const res = xor(neg, elem?.classList?.contains(className));\n                    return Boolean(res);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.classList.add(className);\n                    } else {\n                        elem?.classList.remove(className);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasClass: (className, query) => {\n            return methods.hasClass(className, query, true);\n        },\n        /**\n         * @param {string} classExpr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        classRegex: (classExpr, query, castTo) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    let ret = '';\n                    const classes = Array.from(elem?.classList ?? []);\n                    for (const clazz of classes) {\n                        const match = new RegExp(classExpr).exec(clazz);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            ret = match[1];\n                            break;\n                        }\n                    }\n                    return performCasting(ret, castTo);\n                },\n                setValue: (val) => {\n                    const cl = Array.from(elem?.classList ?? []);\n                    let found = false;\n                    cl.forEach(c => {\n                        const match = new RegExp(classExpr, 'd').exec(c);\n                        if (match === null) {\n                            return;\n                        }\n                        found = true;\n                        elem?.classList.remove(c);\n                        const newCls = replaceStrPart(c, match, val + '');\n                        elem?.classList.add(newCls);\n                    });\n                    // If not found, then set the regExp replacing the\n                    // first capturing group with val, and removing the remaining groups.\n                    if (!found) {\n                        const newCls = getValueFromRegex(classExpr, val + '');\n                        elem?.classList.add(newCls);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attrName\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        attr: (attrName, query, castTo) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    let attrValue = elem?.getAttribute(attrName);\n                    if (attrName.indexOf('-bs-') > 0) {\n                        attrValue = attrValue ?? elem?.getAttribute(attrName.replace('-bs-', '-'));\n                    }\n                    return performCasting(attrValue, castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    const attrVal = val + '';\n                    elem?.setAttribute(attrName, attrVal);\n                    if (attrName.indexOf('-bs-') > 0) {\n                        // Save as old bs\n                        elem?.setAttribute(attrName.replace('-bs-', '-'), attrVal);\n                    }\n                    if (attrName === 'href' || attrName === 'src') {\n                        elem?.setAttribute('data-mce-' + attrName, attrVal);\n                    }\n                }\n            };\n        },\n        /**\n         * Adapted to take into account both data- and data-bs- for Boostrap 4 & 5 compatibility.\n         * @param {string} attrName - Name without data- nor data-bs-\n         * @param {string=} query\n         * @param {string=} castTo\n         * @param {number=} version - 4 or 5 depending the version of BS currently using\n         * @returns {Binding}\n         */\n        attrBS: (attrName, query, castTo, version) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    // If version=4 it has preference BS4 over BS5, it will not remove BS4 prefix\n                    let p1 = '';\n                    let p2 = 'bs-';\n                    if (version === 5) {\n                        p1 = p2;\n                        p2 = '';\n                    }\n                    let value = elem?.getAttribute('data-' + p1 + attrName);\n                    if (value === undefined) {\n                        value = elem?.getAttribute('data-' + p2 + attrName);\n                    }\n                    return performCasting(value || '', castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    const attrVal = val + '';\n                    elem?.setAttribute('data-bs-' + attrName, attrVal);\n                    if (version === 5) {\n                        elem?.removeAttribute('data-' + attrName);\n                    } else {\n                        elem?.setAttribute('data-' + attrName, attrVal);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasAttr: (attr, query, neg) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            return {\n                getValue: () => {\n                    let found = elem?.getAttribute(attrName) !== null;\n                    if (attrValue) {\n                        found = found && elem?.getAttribute(attrName) === attrValue;\n                    }\n                    return xor(neg, found);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.setAttribute(attrName, attrValue || '');\n                        if (attrName === 'href' || attrName === 'src') {\n                            elem?.setAttribute('data-mce-' + attrName, attrValue + '');\n                        }\n                    } else {\n                        elem?.removeAttribute(attrName);\n                        if (attrName === 'href' || attrName === 'src') {\n                            elem?.removeAttribute('data-mce-' + attrName);\n                        }\n                    }\n                }\n            };\n        },\n        /**\n         * Variant to check for compatibility between Bootstrap 4 and 5.\n         * @param {string} attr - attr name without data- nor data-bs-\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @param {number=} version - 4 or 5\n         * @returns {Binding}\n         */\n        hasAttrBS: (attr, query, neg, version) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            const getValuePrefix = (/** @type{string} **/ prefix) => {\n                let found = elem?.getAttribute(prefix + attrName) !== null;\n                if (attrValue) {\n                    found = found && elem?.getAttribute(prefix + attrName) === attrValue;\n                }\n                return xor(neg, found);\n            };\n            return {\n                getValue: () => {\n                    let p1 = 'data-';\n                    let p2 = 'data-bs-';\n                    if (version === 5) {\n                        p2 = p1;\n                        p1 = 'data-bs-';\n                    }\n                    return getValuePrefix(p1) || getValuePrefix(p2);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.setAttribute('data-bs-' + attrName, attrValue || '');\n                        if (version === 5) {\n                            elem?.removeAttribute('data-' + attrName);\n                        } else {\n                            elem?.setAttribute('data-' + attrName, attrValue || '');\n                        }\n                    } else {\n                        elem?.removeAttribute('data-' + attrName);\n                        elem?.removeAttribute('data-bs-' + attrName);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasAttr: (attr, query) => {\n            return methods.hasAttr(attr, query, true);\n        },\n        /**\n         * @param {string} attr - Regex of attr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        attrRegex: function(attr, query, castTo) {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            return {\n                getValue() {\n                    const found = elem?.getAttribute(attrName) !== null;\n                    if (found) {\n                        const match = elem?.getAttribute(attrName)?.match(attrValue);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            return performCasting(match[1], castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                setValue(val) {\n                    const oldValue = elem?.getAttribute(attrName) ?? '';\n                    const match = new RegExp(attrValue, 'd').exec(oldValue);\n                    let newValue;\n                    if (match) {\n                        newValue = replaceStrPart(oldValue, match, val + '');\n                    } else {\n                        newValue = getValueFromRegex(attrValue, val + '');\n                    }\n                    elem?.setAttribute(attrName, newValue);\n                    if (attrName === 'href' || attrName === 'src') {\n                        elem?.setAttribute('data-mce-' + attrName, newValue + '');\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasStyle: function(sty, query, neg) {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = sty.split(\":\");\n            let styName = parts[0].trim();\n            /** @type {string | undefined} */\n            let styValue;\n            if (parts.length > 1) {\n                styValue = parts[1].trim();\n            }\n            return {\n                getValue() {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    const pValue = st.getPropertyValue(styName);\n                    const has = styValue === undefined ? pValue !== '' : pValue === styValue;\n                    return xor(has, neg);\n                },\n                // @ts-ignore\n                setValue(bool) {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    if (xor(bool, neg)) {\n                        st?.setProperty(styName, styValue ?? '');\n                    } else {\n                        st?.removeProperty(styName);\n                    }\n                    // TODO: better way to update data-mce-style\n                    elem?.setAttribute('data-mce-style', st?.cssText ?? '');\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasStyle: (sty, query) => {\n            return methods.hasStyle(sty, query, true);\n        },\n        /**\n         * @param {string} attr - styName:styValue where styValue is a regex with (.*)\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        styleRegex: function(attr, query, castTo) {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\":\");\n            const styName = parts[0].trim();\n            let styValue = '';\n            if (parts.length > 1) {\n                styValue = parts[1].trim();\n            }\n            return {\n                /** @returns {string | null} */\n                getValue() {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    const currentVal = st?.getPropertyValue(styName);\n                    if (currentVal) {\n                        if (styValue) {\n                            const match = new RegExp(styValue).exec(currentVal);\n                            if (match?.[1] && (typeof match[1]) === \"string\") {\n                                return performCasting(match[1], castTo);\n                            }\n                        } else {\n                            return performCasting(currentVal, castTo);\n                        }\n                    }\n                    return performCasting('', castTo);\n                },\n                // @ts-ignore\n                setValue(val) {\n                    let newValue;\n                    // @ts-ignore\n                    const st = elem?.style;\n                    if (styValue) {\n                        // Case val <= 0 && styName contains width or height\n                        if ((styName.includes(\"width\") || styName.includes(\"height\")) && (parseFloat(val + '') <= 0)) {\n                            newValue = '';\n                        } else {\n                            const oldValue = st?.getPropertyValue(styName) ?? '';\n                            if (oldValue) {\n                                const match = new RegExp(styValue, 'd').exec(oldValue);\n                                // @ts-ignore\n                                newValue = replaceStrPart(oldValue, match, val + '');\n                            } else {\n                                newValue = styValue.replace('(.*)', val + '');\n                            }\n                        }\n                    } else {\n                        newValue = val + '';\n                    }\n                    st?.setProperty(styName, newValue);\n                    // TODO: better way to update data-mce-style\n                    elem?.setAttribute('data-mce-style', st?.cssText || '');\n                }\n            };\n        }\n    };\n    return methods;\n};\n\n/**\n * @typedef {Object} Binding\n * @property {() => unknown} getValue\n * @property {(value: string | boolean | number) => void} setValue\n */\n/**\n * @param {string | {get?: string, set?: string, getValue?: string, setValue?: string}} definition\n * @param {Element} elem  - The root of widget\n * @param {string=} castTo  - The type that must be returned\n * @returns {Binding | null}\n */\nexport const createBinding = (definition, elem, castTo) => {\n    /** @type {Binding | null} */\n    let bindFn = null;\n    if (typeof (definition) === 'string') {\n        return evalInContext({...bindingFactory(elem)}, definition, true);\n    } else {\n        // The user provides the get and set functions (for jQuery element) @deprecated\n        // or getValue, setValue (for vanilla JS elements)\n        bindFn = {\n            getValue: () => {\n                let v;\n                if (definition.getValue) {\n                    v = evalInContext({elem}, `(${definition.getValue})(elem)`);\n                } else if (definition.get) {\n                    // @Deprecated. It will be removed in the future.\n                    v = evalInContext({elem: jQuery(elem)}, `(${definition.get})(elem)`);\n                }\n                if (castTo) {\n                    v = performCasting(v, castTo);\n                }\n                return v;\n            },\n            setValue: (v) => {\n                if (definition.setValue) {\n                    evalInContext({elem, v}, `(${definition.setValue})(elem, v)`);\n                } else if (definition.set) {\n                    // @Deprecated. It will be removed in the future.\n                    evalInContext({elem: jQuery(elem), v}, `(${definition.set})(elem, v)`);\n                }\n            }\n        };\n    }\n    return bindFn;\n};\n"],"names":["performCasting","value","type","parsed","indexOf","parseInt","parseFloat","isNaN","console","error","ex","JSON","stringify","xor","a","b","replaceStrPart","str","match","replacement","indices","substring","getValueFromRegex","regexExpr","capturingGroupCount","replace","bindingFactory","el","methods","hasClass","className","query","neg","elem","querySelector","getValue","res","_elem","classList","_elem$classList","contains","Boolean","setValue","bool","add","remove","notHasClass","classRegex","classExpr","castTo","ret","classes","Array","from","clazz","RegExp","exec","val","cl","found","forEach","c","newCls","attr","attrName","attrValue","_elem9","getAttribute","_elem10","attrVal","setAttribute","attrBS","version","p1","p2","_elem14","undefined","_elem15","removeAttribute","hasAttr","parts","split","trim","length","hasAttrBS","getValuePrefix","prefix","notHasAttr","attrRegex","_elem33","_elem33$getAttribute","oldValue","newValue","hasStyle","sty","styValue","styName","pValue","_elem37","style","getPropertyValue","st","_elem38","setProperty","removeProperty","cssText","notHasStyle","styleRegex","_elem40","currentVal","_elem41","includes","definition","bindFn","v","get","set"],"mappings":"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"}