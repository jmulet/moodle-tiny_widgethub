{"version":3,"file":"container.min.js","sources":["../src/container.js"],"sourcesContent":["/**\n * Determines if something is a class or not\n * @param {*} obj\n * @returns {boolean}\n */\nfunction isClass(obj) {\n    const isCtorClass = obj.constructor?.toString()?.substring(0, 5) === 'class';\n    if (obj.prototype === undefined) {\n        return isCtorClass;\n    }\n    const isPrototypeCtorClass = obj.prototype?.constructor?.toString()?.substring(0, 5) === 'class';\n    return isCtorClass || isPrototypeCtorClass;\n}\n\n/**\n * Container for dependency injection\n * @typedef {{name: string, type: 'singleton' | 'service' | 'factory', obj: *, deps: string[]}} DIRegistryEntry\n */\nexport class DIContainer {\n    static clear() {\n        DIContainer.#containerInstances = new Map();\n        DIContainer.#registry = new Map();\n        DIContainer.#singletonInstances = new Map();\n    }\n    /**\n     * @type {Map<import(\"./plugin\").TinyMCE, DIContainer>}\n     */\n    static #containerInstances = new Map();\n    /**\n     * @type {Map<string, DIRegistryEntry>}\n     */\n    static #registry = new Map();\n    /**\n     * @type {Map<string, *>}\n     */\n    static #singletonInstances = new Map();\n    /**\n     * @type {Map<string, *>}\n     */\n    #serviceInstances = new Map();\n\n    /**\n     * @param {*} editor\n     * @returns {DIContainer}\n     */\n    static init(editor) {\n        // There should be an instance of the container for each editor in page\n        let instance = DIContainer.#containerInstances.get(editor);\n        if (!instance) {\n            instance = new DIContainer();\n            instance.registerInstance(\"editor\", editor);\n            DIContainer.#containerInstances.set(editor, instance);\n        }\n        return instance;\n    }\n\n    /**\n     * @param {string=} dependencies\n     * @returns {string[]}\n     */\n    static #parseDeps(dependencies) {\n        if (!dependencies?.trim()) {\n            return [];\n        }\n        return dependencies.split(',').map(e => e.trim());\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerSingleton(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'singleton', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerService(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'service', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerFactory(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'factory', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * Register a instance in the container\n     * @param {string} name\n     * @param {*} obj\n     */\n    registerInstance(name, obj) {\n        this.#serviceInstances.set(name, obj);\n    }\n\n    /**\n     * Allow to retrieve singleton instances without having to instantiate the container\n     * @param {string} name\n     * @param {string[]=} path\n     * @returns {*}\n     */\n    static get(name, path) {\n        path = path || [];\n        if (name.indexOf(\",\") > 0) {\n            return name.split(\",\").map(e => DIContainer.get(e.trim(), path));\n        }\n        if (path.indexOf(name) >= 0) {\n            throw new Error(`Circular dependency detected on ${name}`);\n        }\n        path.push(name);\n        const reg = DIContainer.#registry.get(name);\n        if (!reg) {\n            throw new Error(`Cannot find a registry for dependency ${name}`);\n        } else if (reg.type !== 'singleton') {\n            throw new Error(`Non singleton dependency ${name} must be invoked from an instance of the container.`);\n        }\n        if (DIContainer.#singletonInstances.has(reg.name)) {\n            return DIContainer.#singletonInstances.get(reg.name);\n        }\n        // Create an instance\n        const deps = (reg.deps ?? []).map(name => DIContainer.get(name, path));\n        let resolved;\n        if (isClass(reg.obj)) {\n            // Has to instantiate a class.\n            resolved = new reg.obj(...deps);\n        } else if (typeof (reg.obj) === 'function' && deps.length) {\n            // Prevent from calling functions like jQuery if no dependencies are passed\n            // Has to call the function.\n            resolved = reg.obj(...deps);\n        } else {\n            resolved = reg.obj;\n        }\n        DIContainer.#singletonInstances.set(name, resolved);\n        return resolved;\n    }\n\n    /**\n     * @param {string} name\n     * @param {string[]=} path\n     * @returns {*} - An instance of the \"name\" in the correct scope\n     */\n    get(name, path) {\n        path = path || [];\n        if (name.indexOf(\",\") > 0) {\n            return name.split(\",\").map(e => this.get(e.trim(), path));\n        }\n        if (path.indexOf(name) >= 0) {\n            throw new Error(`Circular dependency detected on ${name}`);\n        }\n        path.push(name);\n        // Check if already exists an instance with this name.\n        if (this.#serviceInstances.has(name)) {\n            return this.#serviceInstances.get(name);\n        }\n        const reg = DIContainer.#registry.get(name);\n        if (!reg) {\n            throw new Error(`Cannot find a registry for dependency ${name}`);\n        }\n        switch (reg.type) {\n            case ('singleton'): return this.#getInstance(DIContainer.#singletonInstances, reg, path);\n            case ('service'): return this.#getInstance(this.#serviceInstances, reg, path);\n            case ('factory'): {\n                const deps = (reg.deps ?? []).map(name => this.get(name, path));\n                if (isClass(reg.obj)) {\n                    // Has to instantiate a class.\n                    /** @param {*[]} args */\n                    return (...args) => {\n                        return new reg.obj(...deps, ...args);\n                    };\n                } else if (typeof (reg.obj) === 'function') {\n                    // Has to call the function.\n                    /** @param {*[]} args */\n                    return (...args) => {\n                        return reg.obj(...deps, ...args);\n                    };\n                }\n            }\n        }\n        throw new Error(`Invalid registry type ${reg.type}`);\n    }\n\n    /**\n     * @param {Map<string, *>} map\n     * @param {DIRegistryEntry} reg\n     * @param {string[]} path\n     * @returns {*}\n     */\n    #getInstance(map, reg, path) {\n        if (map.has(reg.name)) {\n            return map.get(reg.name);\n        }\n        // Create an instance\n        const instance = this.#createInstance(reg, path);\n        map.set(reg.name, instance);\n        return instance;\n    }\n\n    /**\n     * @param {DIRegistryEntry} reg\n     * @param {string[]} path\n     * @returns {*}\n     */\n    #createInstance(reg, path) {\n        // Need to get all the dependencies.\n        const deps = (reg.deps ?? []).map(name => this.get(name, path));\n        if (isClass(reg.obj)) {\n            // Has to instantiate a class.\n            return new reg.obj(...deps);\n        } else if (typeof (reg.obj) === 'function' && deps.length) {\n            // Prevent from calling functions like jQuery if no dependencies are passed\n            // Has to call the function.\n            return reg.obj(...deps);\n        } else {\n            // Return directly.\n            return reg.obj;\n        }\n    }\n}\n"],"names":["isClass","obj","isCtorClass","constructor","toString","substring","undefined","prototype","isPrototypeCtorClass","DIContainer","containerInstances","Map","registry","singletonInstances","editor","instance","get","registerInstance","set","dependencies","trim","split","map","e","name","type","deps","parseDeps","serviceInstances","path","indexOf","Error","push","reg","has","resolved","length","this","getInstance","args","createInstance"],"mappings":"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"}