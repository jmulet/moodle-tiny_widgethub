{"version":3,"file":"container.min.js","sources":["../src/container.js"],"sourcesContent":["/**\n * Determines if something is a class or not\n * @param {*} obj\n * @returns {boolean}\n */\nfunction isClass(obj) {\n    const isCtorClass = obj.constructor?.toString()?.substring(0, 5) === 'class';\n    if (obj.prototype === undefined) {\n        return isCtorClass;\n    }\n    const isPrototypeCtorClass = obj.prototype?.constructor?.toString()?.substring(0, 5) === 'class';\n    return isCtorClass || isPrototypeCtorClass;\n}\n\n/**\n * Container for dependency injection\n * @typedef {{name: string, type: 'singleton' | 'service' | 'factory', obj: *, deps: string[]}} DIRegistryEntry\n */\nexport class DIContainer {\n    static clear() {\n        DIContainer.#containerInstances = new Map();\n        DIContainer.#registry = new Map();\n        DIContainer.#singletonInstances = new Map();\n    }\n    /**\n     * @type {Map<import(\"./plugin\").TinyMCE, DIContainer>}\n     */\n    static #containerInstances = new Map();\n    /**\n     * @type {Map<string, DIRegistryEntry>}\n     */\n    static #registry = new Map();\n    /**\n     * @type {Map<string, *>}\n     */\n    static #singletonInstances = new Map();\n    /**\n     * @type {Map<string, *>}\n     */\n    #serviceInstances = new Map();\n\n    /**\n     * @param {*} editor\n     * @returns {DIContainer}\n     */\n    static init(editor) {\n        // There should be an instance of the container for each editor in page\n        let instance = DIContainer.#containerInstances.get(editor);\n        if (!instance) {\n            instance = new DIContainer();\n            instance.registerInstance(\"editor\", editor);\n            DIContainer.#containerInstances.set(editor, instance);\n        }\n        return instance;\n    }\n\n    /**\n     * @param {string=} dependencies\n     * @returns {string[]}\n     */\n    static #parseDeps(dependencies) {\n        if (!dependencies?.trim()) {\n            return [];\n        }\n        return dependencies.split(',').map(e => e.trim());\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerSingleton(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'singleton', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerService(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'service', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * @param {string} name\n     * @param {*} obj\n     * @param {string=} dependencies\n     */\n    static registerFactory(name, obj, dependencies) {\n        this.#registry.set(name, {name, type: 'factory', obj, deps: DIContainer.#parseDeps(dependencies)});\n    }\n\n    /**\n     * Register an instance in the container\n     * @param {string} name\n     * @param {*} obj\n     */\n    registerInstance(name, obj) {\n        this.#serviceInstances.set(name, obj);\n    }\n\n    /**\n     * Allow to retrieve singleton instances without having to instantiate the container\n     * @param {string} name\n     * @returns {*}\n     */\n    static get(name) {\n        if (name.indexOf(\",\") > 0) {\n            return name.split(\",\").map(e => DIContainer.#injectStatic(e.trim(), []));\n        }\n        return DIContainer.#injectStatic(name, []);\n    }\n\n    /**\n     * @param {string} name\n     * @param {string[]} path\n     * @returns {*}\n     */\n    static #injectStatic(name, path) {\n        const reg = DIContainer.#registry.get(name);\n        if (!reg) {\n            throw new Error(`Cannot find a registry for dependency ${name}`);\n        } else if (reg.type !== 'singleton') {\n            throw new Error(`Non singleton dependency ${name} must be invoked from an instance of the container.`);\n        }\n        if (DIContainer.#singletonInstances.has(reg.name)) {\n            return DIContainer.#singletonInstances.get(reg.name);\n        }\n        // Create an instance\n        if (path.indexOf(name) >= 0) {\n            throw new Error(`Circular dependency detected on ${name}`);\n        }\n        path.push(name);\n        const deps = (reg.deps ?? []).map(name => DIContainer.#injectStatic(name, path));\n        let resolved;\n        if (isClass(reg.obj)) {\n            // Has to instantiate a class.\n            resolved = new reg.obj(...deps);\n        } else if (typeof (reg.obj) === 'function' && deps.length) {\n            // Prevent from calling functions like jQuery if no dependencies are passed\n            // Has to call the function.\n            resolved = reg.obj(...deps);\n        } else {\n            resolved = reg.obj;\n        }\n        DIContainer.#singletonInstances.set(name, resolved);\n        return resolved;\n    }\n\n    /**\n     * @param {string} name\n     * @returns {*} - An instance of the \"name\" in the correct scope\n     */\n    get(name) {\n        if (name.indexOf(\",\") > 0) {\n            return name.split(\",\").map(e => this.#inject(e.trim(), []));\n        }\n        return this.#inject(name, []);\n    }\n\n    /**\n     * @param {string} name\n     * @param {string[]} path\n     * @returns {*} - An instance of the \"name\" in the correct scope\n     */\n    #inject(name, path) {\n        // Check if already exists an instance with this name.\n        if (this.#serviceInstances.has(name)) {\n            return this.#serviceInstances.get(name);\n        }\n        const reg = DIContainer.#registry.get(name);\n        if (!reg) {\n            throw new Error(`Cannot find a registry for dependency ${name}`);\n        }\n        switch (reg.type) {\n            case ('singleton'): return this.#getInstance(DIContainer.#singletonInstances, reg, path);\n            case ('service'): return this.#getInstance(this.#serviceInstances, reg, path);\n            case ('factory'): {\n                const deps = (reg.deps ?? []).map(name => this.#inject(name, path));\n                if (isClass(reg.obj)) {\n                    // Has to instantiate a class.\n                    /** @param {*[]} args */\n                    return (...args) => {\n                        return new reg.obj(...deps, ...args);\n                    };\n                } else if (typeof (reg.obj) === 'function') {\n                    // Has to call the function.\n                    /** @param {*[]} args */\n                    return (...args) => {\n                        return reg.obj(...deps, ...args);\n                    };\n                }\n            }\n        }\n        throw new Error(`Invalid registry type ${reg.type}`);\n    }\n\n    /**\n     * @param {Map<string, *>} map\n     * @param {DIRegistryEntry} reg\n     * @param {string[]} path\n     * @returns {*}\n     */\n    #getInstance(map, reg, path) {\n        if (map.has(reg.name)) {\n            return map.get(reg.name);\n        }\n        if (path.indexOf(reg.name) >= 0) {\n            throw new Error(`Circular dependency detected on ${reg.name}`);\n        }\n        // Create an instance\n        path.push(reg.name);\n        const instance = this.#createInstance(reg, path);\n        map.set(reg.name, instance);\n        return instance;\n    }\n\n    /**\n     * @param {DIRegistryEntry} reg\n     * @param {string[]} path\n     * @returns {*}\n     */\n    #createInstance(reg, path) {\n        // Need to get all the dependencies.\n        const deps = (reg.deps ?? []).map(name => this.#inject(name, path));\n        if (isClass(reg.obj)) {\n            // Has to instantiate a class.\n            return new reg.obj(...deps);\n        } else if (typeof (reg.obj) === 'function' && deps.length) {\n            // Prevent from calling functions like jQuery if no dependencies are passed\n            // Has to call the function.\n            return reg.obj(...deps);\n        } else {\n            // Return directly.\n            return reg.obj;\n        }\n    }\n}\n"],"names":["isClass","obj","isCtorClass","constructor","toString","substring","undefined","prototype","isPrototypeCtorClass","DIContainer","containerInstances","Map","registry","singletonInstances","editor","instance","get","registerInstance","set","dependencies","trim","split","map","e","name","type","deps","parseDeps","serviceInstances","indexOf","injectStatic","path","reg","Error","has","push","resolved","length","this","inject","getInstance","args","createInstance"],"mappings":"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"}