{"version":3,"file":"dependencies.min.js","sources":["../../src/extension/dependencies.js"],"sourcesContent":["/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2025 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {subscribe} from \"../extension\";\nimport {getWidgetDict} from \"../options\";\nimport {evalInContext} from \"../util\";\n\nconst JSAREACLASSNAME = 'tiny_widgethub-jsarea';\n/**\n/**\n * Adds the required scripts defined in the list\n * @param {import(\"../plugin\").TinyMCE} editor\n * @param {string[] | undefined} requireList\n * @returns {number}\n */\nexport function addRequires(editor, requireList) {\n    let dependenciesUpdated = 0;\n    try {\n    const jsareaSelector = `div.${JSAREACLASSNAME}`;\n    const affectedWidgets = Object.values(getWidgetDict(editor)).filter(w => w.selectors && w.prop('requires'));\n\n    const tiny = editor.getBody();\n    let jsArea = tiny.querySelector(jsareaSelector);\n\n    // If no requireList is passed, then analyze the page and add requires that must be there!\n    if (!requireList) {\n        requireList = [];\n        affectedWidgets.forEach(w => {\n            if (anyMatchesSelectors(tiny, w.selectors || [])) {\n                requireList?.push(w.prop('requires')?.trim());\n            }\n        });\n    }\n\n    // Clear unused requires first\n    cleanUnusedRequires(editor, affectedWidgets);\n    jsArea = tiny.querySelector(jsareaSelector);\n\n    if (!jsArea && requireList.length > 0) {\n        const spacer = editor.dom.create('p', {}, '<br>');\n        jsArea = editor.dom.create('div', {\"class\": JSAREACLASSNAME});\n        tiny.append(spacer);\n        tiny.append(jsArea);\n    }\n\n    // Check the existence of script area\n    const scriptsToInsert = requireList.filter((requireScript) => {\n        if (!requireScript.endsWith(\".js\")) {\n            return false;\n        }\n        return jsArea?.querySelector(`script[src=\"${requireScript}\"]`) === null;\n    });\n\n    if (jsArea && scriptsToInsert.length > 0) {\n        // Insert the scripts in the area\n        scriptsToInsert.forEach(scriptUrl => {\n            const scriptNode = editor.dom.create(\"script\",\n                {src: scriptUrl, type: \"mce-no/type\", \"data-mce-src\": scriptUrl});\n            jsArea.append(scriptNode);\n            dependenciesUpdated++;\n        });\n    }\n    } catch (ex) {\n        console.error(\"A problem occurred adding dependencies:\", ex);\n    }\n    return dependenciesUpdated;\n}\n\n/**\n * Removes those scripts that are not longer required\n * @param {HTMLElement} tiny\n * @param {string | string[]} selectors\n * @returns {boolean}\n */\nfunction anyMatchesSelectors(tiny, selectors) {\n    if (typeof (selectors) === 'string') {\n        selectors = [selectors];\n    }\n    let anyFound = false;\n    try {\n        anyFound = [...tiny.querySelectorAll(selectors[0] ?? '')].some(e => {\n            if (selectors.length === 1) {\n                return true;\n            }\n            // Matches all other conditions\n            let match = true;\n            for (let i = 1; i < selectors.length; i++) {\n                match = match && e.querySelector(selectors[i]) !== null;\n                if (!match) {\n                    break;\n                }\n            }\n            return match;\n        });\n    } catch (ex) {\n        console.error(\"Error in anyMatchesSelectors:\", ex);\n    }\n    return anyFound;\n}\n\n/**\n * Removes those scripts that are not longer required\n * @param {import(\"../plugin\").TinyMCE} editor\n * @param {import(\"../options\").Widget[]} [affectedWidgets]\n * @returns {number}\n */\nexport function cleanUnusedRequires(editor, affectedWidgets) {\n    let changes = 0;\n    try {\n    const tiny = editor.getBody();\n    const jsArea = tiny.querySelector(`div.${JSAREACLASSNAME}`);\n    if (!jsArea) {\n       return 0;\n    }\n\n    if (!affectedWidgets) {\n        affectedWidgets = Object.values(getWidgetDict(editor)).filter(w => w.selectors && w.prop('requires'));\n    }\n    // All scripts in jsArea\n    /** @type {NodeListOf<HTMLScriptElement>} */\n    const allScripts = jsArea.querySelectorAll(\"script\");\n    allScripts.forEach((scriptElem) => {\n        const src = (scriptElem.src || '')?.trim();\n\n        // Match the widget with this src\n        // @ts-ignore\n        const widgetFound = affectedWidgets.filter(w => w.prop('requires')?.trim() === src)[0];\n        if (!widgetFound) {\n            scriptElem.remove();\n            changes++;\n            return;\n        }\n        const anyInstancesFound = anyMatchesSelectors(tiny, widgetFound.selectors ?? []);\n        if (!anyInstancesFound) {\n             // Script no longer needed\n            scriptElem.remove();\n            changes++;\n        }\n    });\n    // Get rid of jsArea if no scripts are left\n    if (!jsArea.querySelectorAll(\"script\").length) {\n        jsArea.remove();\n        changes++;\n    }\n    } catch (ex) {\n        console.error(\"Error while removing unused dependencies:\", ex);\n    }\n    return changes;\n}\n/**\n * @param {import(\"../plugin\").TinyMCE} editor\n * @param {import(\"../options\").Widget} widget\n * @param {Record<string, any>} ctxFromDialogue\n */\nfunction widgetInserted(editor, widget, ctxFromDialogue) {\n    try {\n      // Determine if should add any requires\n      const requireList = [];\n      // Treat the case of requires being an object (keys are the conditions to be met)\n      if (widget.prop('requires')) {\n         const parts = widget.prop('requires').split(\"|\");\n         let conditionFullfilled = true;\n            if (parts.length > 1) {\n               conditionFullfilled = evalInContext(ctxFromDialogue, parts[1]);\n            }\n         if (conditionFullfilled) {\n            requireList.push(parts[0]?.trim());\n         }\n      }\n      let changes = 0;\n      if (requireList.length > 0) {\n          // Now handle the filtered list of requires\n          changes += addRequires(editor, requireList);\n      } else {\n          // Always try to remove unused requires\n          changes += cleanUnusedRequires(editor);\n      }\n      if (changes > 0) {\n        editor.setDirty(true);\n      }\n    } catch (ex) {\n        console.error(\"An error occurre when treating dependencies of inserted widget:\", ex);\n    }\n}\n\nsubscribe('contentSet', addRequires);\nsubscribe('widgetInserted', widgetInserted);\nsubscribe('widgetRemoved', cleanUnusedRequires);\nsubscribe('ctxAction', cleanUnusedRequires);\n"],"names":["addRequires","editor","requireList","dependenciesUpdated","jsareaSelector","affectedWidgets","Object","values","filter","w","selectors","prop","tiny","getBody","jsArea","querySelector","forEach","anyMatchesSelectors","push","_w$prop","trim","cleanUnusedRequires","length","spacer","dom","create","append","scriptsToInsert","requireScript","endsWith","scriptUrl","scriptNode","src","type","ex","console","error","anyFound","querySelectorAll","some","e","match","i","changes","scriptElem","_ref","widgetFound","remove","widget","ctxFromDialogue","parts","split","conditionFullfilled","_parts$","setDirty"],"mappings":"kSAmCgBA,YAAYC,OAAQC,iBAC5BC,oBAAsB,YAEpBC,eAAkB,4BAClBC,gBAAkBC,OAAOC,QAAO,0BAAcN,SAASO,QAAOC,GAAKA,EAAEC,WAAaD,EAAEE,KAAK,cAEzFC,KAAOX,OAAOY,cAChBC,OAASF,KAAKG,cAAcX,mBAG3BF,cACDA,YAAc,GACdG,gBAAgBW,SAAQP,6BAChBQ,oBAAoBL,KAAMH,EAAEC,WAAa,2BACzCR,kDAAagB,qBAAKT,EAAEE,KAAK,sCAAPQ,QAAoBC,aAMlDC,oBAAoBpB,OAAQI,iBAC5BS,OAASF,KAAKG,cAAcX,iBAEvBU,QAAUZ,YAAYoB,OAAS,EAAG,OAC7BC,OAAStB,OAAOuB,IAAIC,OAAO,IAAK,GAAI,QAC1CX,OAASb,OAAOuB,IAAIC,OAAO,MAAO,OAjClB,0BAkChBb,KAAKc,OAAOH,QACZX,KAAKc,OAAOZ,cAIVa,gBAAkBzB,YAAYM,QAAQoB,oCACnCA,cAAcC,SAAS,QAGuC,wBAA5Df,yCAAQC,cAAe,eAAca,uBAG5Cd,QAAUa,gBAAgBL,OAAS,GAEnCK,gBAAgBX,SAAQc,kBACdC,WAAa9B,OAAOuB,IAAIC,OAAO,SACjC,CAACO,IAAKF,UAAWG,KAAM,6BAA+BH,YAC1DhB,OAAOY,OAAOK,YACd5B,yBAGN,MAAO+B,IACLC,QAAQC,MAAM,0CAA2CF,WAEtD/B,6BASFc,oBAAoBL,KAAMF,WACJ,iBAAfA,YACRA,UAAY,CAACA,gBAEb2B,UAAW,MAEXA,SAAW,IAAIzB,KAAK0B,iBAAiB5B,UAAU,IAAM,KAAK6B,MAAKC,OAClC,IAArB9B,UAAUY,cACH,MAGPmB,OAAQ,MACP,IAAIC,EAAI,EAAGA,EAAIhC,UAAUY,SAC1BmB,MAAQA,OAA2C,OAAlCD,EAAEzB,cAAcL,UAAUgC,IACtCD,OAF6BC,YAM/BD,SAEb,MAAOP,IACLC,QAAQC,MAAM,gCAAiCF,WAE5CG,kBASKhB,oBAAoBpB,OAAQI,qBACpCsC,QAAU,YAER/B,KAAOX,OAAOY,UACdC,OAASF,KAAKG,cAAe,iCAC9BD,cACK,EAGLT,kBACDA,gBAAkBC,OAAOC,QAAO,0BAAcN,SAASO,QAAOC,GAAKA,EAAEC,WAAaD,EAAEE,KAAK,eAI1EG,OAAOwB,iBAAiB,UAChCtB,SAAS4B,4BACVZ,iBAAOY,WAAWZ,KAAO,0BAAnBa,KAAwBzB,OAI9B0B,YAAczC,gBAAgBG,QAAOC,yCAAKA,EAAEE,KAAK,gDAAaS,UAAWY,OAAK,OAC/Ec,mBACDF,WAAWG,cACXJ,UAGsB1B,oBAAoBL,KAAMkC,YAAYpC,WAAa,MAGzEkC,WAAWG,SACXJ,cAIH7B,OAAOwB,iBAAiB,UAAUhB,SACnCR,OAAOiC,SACPJ,WAEF,MAAOT,IACLC,QAAQC,MAAM,4CAA6CF,WAExDS,iCAsCD,aAAc3C,sCACd,2BAhCcC,OAAQ+C,OAAQC,2BAG5B/C,YAAc,MAEhB8C,OAAOrC,KAAK,YAAa,OACpBuC,MAAQF,OAAOrC,KAAK,YAAYwC,MAAM,SACxCC,qBAAsB,iBACnBF,MAAM5B,OAAS,IAChB8B,qBAAsB,uBAAcH,gBAAiBC,MAAM,KAE7DE,oBACDlD,YAAYgB,qBAAKgC,MAAM,6BAANG,QAAUjC,YAG7BuB,QAAU,EACVzC,YAAYoB,OAAS,EAErBqB,SAAW3C,YAAYC,OAAQC,aAG/ByC,SAAWtB,oBAAoBpB,QAE/B0C,QAAU,GACZ1C,OAAOqD,UAAS,GAElB,MAAOpB,IACLC,QAAQC,MAAM,kEAAmEF,iCAM/E,gBAAiBb,8CACjB,YAAaA"}