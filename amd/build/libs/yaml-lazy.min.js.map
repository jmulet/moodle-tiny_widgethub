{"version":3,"file":"yaml-lazy.min.js","sources":["../../src/libs/yaml-lazy.js"],"sourcesContent":["\n// @ts-nocheck\n/** @ts-ignore */\n/* eslint-disable */\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR$1 = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR$1:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n            const tags = {};\n            visit(doc.contents, (_key, node) => {\n                if (isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            prevAnchors ?? (prevAnchors = anchorNames(doc));\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (isScalar(ref.node) || isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc, ctx) {\n        let nodes;\n        if (ctx?.aliasResolveCache) {\n            nodes = ctx.aliasResolveCache;\n        }\n        else {\n            nodes = [];\n            visit(doc, {\n                Node: (_key, node) => {\n                    if (isAlias(node) || hasAnchor(node))\n                        nodes.push(node);\n                }\n            });\n            if (ctx)\n                ctx.aliasResolveCache = nodes;\n        }\n        let found = undefined;\n        for (const node of nodes) {\n            if (node === this)\n                break;\n            if (node.anchor === this.source)\n                found = node;\n        }\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc, ctx);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends NodeBase {\n    constructor(value) {\n        super(SCALAR$1);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (isDocument(value))\n        value = value.contents;\n    if (isNode(value))\n        return value;\n    if (isPair(value)) {\n        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            ref.anchor ?? (ref.anchor = onAnchor(value));\n            return new Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[SEQ]\n                    : schema[MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    // Leading | or > is added later\n    let header = (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (!literal) {\n        const foldedValue = value\n            .replace(/\\n+/g, '\\n$&')\n            .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n            .replace(/\\n+/g, `$&${indent}`);\n        let literalFallback = false;\n        const foldOptions = getFoldOptions(ctx, true);\n        if (blockQuote !== 'folded' && type !== Scalar.BLOCK_FOLDED) {\n            foldOptions.onOverflow = () => {\n                literalFallback = true;\n            };\n        }\n        const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);\n        if (!literalFallback)\n            return `>${header}\\n${indent}${body}`;\n    }\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `|${header}\\n${indent}${start}${value}${end}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (/^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.BLOCK_FOLDED:\n            case Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (isScalar(item)) {\n        obj = item.value;\n        let match = tags.filter(t => t.identify?.(obj));\n        if (match.length > 1) {\n            const testMatch = match.filter(t => t.test);\n            if (testMatch.length > 0)\n                match = testMatch;\n        }\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;\n    if (anchor && anchorIsValid(anchor)) {\n        anchors.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n    if (isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : isScalar(node)\n            ? stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key) || (!isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify$1(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify$1(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        console.warn(warning);\n    }\n}\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (isScalar(key) &&\n        (!key.type || key.type === Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (isNode(key) && key.addToJSMap)\n        key.addToJSMap(ctx, map, value);\n    // TODO: Should drop this special case for bare << handling\n    else if (isMergeKey(ctx, key))\n        addMergeToJSMap(ctx, map, value);\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx?.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nfunction createPair(key, value, ctx) {\n    const k = createNode(key, undefined, ctx);\n    const v = createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, NODE_TYPE, { value: PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (isNode(key))\n            key = key.clone(schema);\n        if (isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify$1(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify$1(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nfunction findPair(items, key) {\n    const k = isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (isScalar(prev.value) && isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)\n};\n\nclass YAMLSeq extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (isScalar(prev) && isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)\n};\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nconst floatNaN$1 = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp$1 = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float$1 = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nconst intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify$1(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify$2(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct$1 = {\n    identify: value => intIdentify$2(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),\n    stringify: node => intStringify$1(node, 8, '0o')\n};\nconst int$1 = {\n    identify: intIdentify$2,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex$1 = {\n    identify: value => intIdentify$2(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),\n    stringify: node => intStringify$1(node, 16, '0x')\n};\n\nconst schema$2 = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct$1,\n    int$1,\n    intHex$1,\n    floatNaN$1,\n    floatExp$1,\n    float$1\n];\n\nfunction intIdentify$1(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify$1,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema$1 = [map, seq].concat(jsonScalars, jsonError);\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        type ?? (type = Scalar.BLOCK_LITERAL);\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nfunction resolvePairs(seq, onError) {\n    if (isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (isPair(item))\n                continue;\n            else if (isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair(new Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = isPair(item) ? item : new Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nclass YAMLSet extends YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair(key.key, null);\n        else\n            pair = new Pair(key, null);\n        const prev = findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = findPair(this.items, key);\n        return !keepPair && isPair(pair)\n            ? isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    merge,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nconst schemas = new Map([\n    ['core', schema$2],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema],\n    ['yaml-1.1', schema]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float: float$1,\n    floatExp: floatExp$1,\n    floatNaN: floatNaN$1,\n    floatTime,\n    int: int$1,\n    intHex: intHex$1,\n    intOct: intOct$1,\n    intTime,\n    map,\n    merge,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:merge': merge,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge)\n            ? schemaTags.concat(merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR$1, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify$1(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify$1(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (isScalar(a) && isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[SCALAR$1];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[SCALAR$1];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR$1]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR$1];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[SCALAR$1];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR$1];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        pos ?? (pos = before.length);\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { Scalar, parse, stringify };\n"],"names":["src","reviver","options","_reviver","undefined","doc","source","lineCounter","prettyErrors","parseOptions","parser","Parser","addNewLine","composer","Composer","_doc","compose","parse","length","logLevel","errors","push","YAMLParseError","range","slice","forEach","prettifyError","warnings","parseDocument","warning","warn","toJS","Object","assign","value","replacer","_replacer","Array","isArray","indent","Math","round","keepUndefined","isDocument","toString","Document","ALIAS","Symbol","for","DOC","MAP","PAIR","SCALAR$1","SEQ","NODE_TYPE","isAlias","node","isMap","isPair","isScalar","isSeq","isCollection","isNode","hasAnchor","anchor","BREAK","SKIP","REMOVE","visit","visitor","visitor_","Collection","Node","Value","Alias","Map","Scalar","Seq","initVisitor","visit_","contents","freeze","key","path","ctrl","_visitor$Map","_visitor$Seq","Pair","_visitor$Pair","_visitor$Scalar","_visitor$Alias","callVisitor","parent","items","pt","Error","replaceNode","concat","i","ci","splice","ck","cv","escapeChars","Directives","constructor","yaml","tags","docStart","docEnd","defaultYaml","defaultTags","clone","copy","this","atDocument","res","version","atNextDocument","explicit","add","line","onError","parts","trim","split","name","shift","handle","prefix","test","tagName","verbatim","suffix","match","decodeURIComponent","error","String","tagString","tag","entries","startsWith","substring","replace","ch","lines","tagEntries","tagNames","_key","keys","some","tn","join","anchorIsValid","sa","JSON","stringify","anchorNames","root","anchors","Set","findNewAnchor","exclude","has","applyReviver","obj","val","len","v0","v1","k","from","get","delete","set","call","arg","ctx","map","v","toJSON","data","aliasCount","count","onCreate","keep","Number","NodeBase","type","defineProperty","create","getPrototypeOf","getOwnPropertyDescriptors","mapAsMap","maxAliasCount","onAnchor","TypeError","mapKeyWarned","values","resolve","nodes","found","aliasResolveCache","_arg","msg","ReferenceError","getAliasCount","_onComment","_onChompKeep","verifyAliasOrder","implicitKey","item","c","kc","vc","max","isScalarValue","BLOCK_FOLDED","BLOCK_LITERAL","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","createNode","schema","_ctx$schema$MAP$creat","Boolean","BigInt","valueOf","aliasDuplicateObjects","onTagObj","sourceObjects","ref","_tagName","tagObj","filter","t","find","format","identify","findTagObject","iterator","_tagObj2","nodeClass","_tagObj2$nodeClass","default","collectionFromPath","isInteger","a","isEmptyPath","next","done","configurable","enumerable","writable","it","addIn","rest","deleteIn","getIn","keepScalar","hasAllNullValues","allowScalar","every","n","commentBefore","comment","hasIn","setIn","stringifyComment","str","indentComment","lineComment","endsWith","includes","foldFlowLines","text","mode","indentAtStart","lineWidth","minContentWidth","onFold","onOverflow","endStep","folds","escapedFolds","prev","end","overflow","escStart","escEnd","consumeMoreIndentedLines","j","fold","start","getFoldOptions","isBlock","containsDocumentMarker","doubleQuotedString","json","doubleQuotedAsJSON","minMultiLineLength","doubleQuotedMinMultiLineLength","code","substr","singleQuotedString","singleQuote","quotedString","qs","hasDouble","hasSingle","blockEndNewlines","RegExp","blockString","onComment","onChompKeep","blockQuote","commentString","forceBlockIndent","literal","indentLength","limit","strLen","lineLengthOverLimit","chomp","endStart","endNlPos","indexOf","startEnd","startWithSpace","startNlPos","header","foldedValue","literalFallback","foldOptions","body","stringifyString","inFlow","ss","_stringify","_type","actualString","indentStep","_tag$test","compat","plainString","defaultKeyType","defaultStringType","createStringifyContext","opt","directives","falseStr","flowCollectionPadding","indentSeq","nullStr","simpleKeys","trueStr","toStringOptions","collectionStyle","repeat","stringify$1","resolvedAliases","_ctx$resolvedAliases","o","_t$identify2","testMatch","getTagObject","props","stringifyProps","console","merge","description","addToJSMap","addMergeToJSMap","mergeValue","srcMap","prototype","hasOwnProperty","addPairToJSMap","isMergeKey","jsKey","stringKey","strCtx","inStringifyKey","strKey","jsonStr","stringifyKey","jsValue","createPair","_","allNullValues","keyComment","explicitKey","vsb","vcb","valueComment","keyCommentDone","chompKeep","spaceBefore","flow","valueCommentDone","valueStr","ws","vs0","nl0","hasNewline","hasPropsLine","sp0","stringifyPair","stringifyCollection","collection","stringifyFlowCollection","stringifyBlockCollection","blockItemPrefix","flowChars","itemIndent","itemCtx","addCommentBefore","ik","fcPadding","reqNewline","linesAtValue","iv","reduce","sum","ic","trimStart","findPair","YAMLMap","sortMapEntries","sort","pair","overwrite","_pair","sortEntries","_this$schema","findIndex","Type","YAMLSeq","idx","asItemIndex","seq","string","nullTag","boolTag","stringifyNumber","minFractionDigits","num","isFinite","isNaN","d","floatNaN$1","toLowerCase","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","floatExp$1","parseFloat","toExponential","float$1","dot","intIdentify$2","intResolve$1","offset","radix","intAsBigInt","parseInt","intStringify$1","intOct$1","_onError","int$1","intHex$1","schema$2","intIdentify$1","stringifyJSON","_ref14","schema$1","_ref16","binary","Uint8Array","atob","buffer","charCodeAt","buf","btoa","s","fromCharCode","ceil","resolvePairs","cn","createPairs","iterable","pairs","YAMLOMap","bind","super","omap","seenKeys","boolStringify","trueTag","falseTag","floatNaN","floatExp","float","f","intIdentify","intResolve","sign","intStringify","intBin","intOct","int","intHex","YAMLSet","keepPair","parseSexagesimal","asBigInt","p","stringifySexagesimal","_60","unshift","padStart","intTime","floatTime","timestamp","Date","year","month","day","hour","minute","second","millisec","date","UTC","tz","abs","_ref21","toISOString","schemas","tagsByName","bool","null","coreKnownTags","getTags","customTags","schemaName","addMergeTag","schemaTags","sortMapEntriesByKey","b","Schema","resolveKnownTags","toStringDefaults","knownTags","keepSourceTokens","strict","stringKeys","uniqueKeys","_options","_directives","setSchema","assertCollection","createAlias","keyToStr","asStr","anchorPrefix","setAnchors","aliasObjects","prevAnchors","createNodeAnchors","sv","jsonArg","hasDirectives","dir","cs","contentComment","_doc$directives","dc","stringifyDocument","YAMLError","pos","message","YAMLWarning","lc","linePos","col","lineStr","lineStarts","min","pointer","resolveProps","tokens","indicator","parentIndent","startOnNewline","atNewline","hasSpace","commentSep","reqSpace","tab","newlineAfterProp","comma","token","cb","last","containsNewline","st","sep","flowIndentCheck","fc","mapIncludes","search","isEqual","startColMsg","resolveEnd","blockMsg","resolveCollection","CN","coll","bm","composeNode","composeEmptyNode","atRoot","commentEnd","collItem","keyProps","atKey","keyStart","keyNode","valueProps","valueNode","srcToken","resolveBlockMap","bs","resolveBlockSeq","fcName","prevItemComment","loop","endRange","expectedEnd","ce","ee","cePos","toUpperCase","resolveFlowCollection","Coll","resolveBlockScalar","scalar","ts","parseBlockScalarHeader","first","m","splitLines","chompStart","content","trimIndent","contentStart","prevMoreIndented","crlf","resolveFlowScalar","rel","badChar","foldLines","plainValue","singleQuotedValue","foldNewline","cc","escapeCodes","x","u","U","parseCharCode","raw","wsStart","doubleQuotedValue","valueEnd","re","exec","lastIndex","e","r","N","L","P","fromCodePoint","composeScalar","tagToken","matchWithTest","_tag$test2","kt","findScalarTagByName","_tag$test3","_tag$test4","findScalarTagByTest","emptyScalarPosition","before","isSrcToken","alias","composeAlias","nl","lastProp","expType","_tag2","composeCollection","getErrorPos","parsePrelude","prelude","atComment","afterEmptyLine","atDirectives","decorate","afterDoc","apply","streamInfo","forceDoc","endOffset","opts","contentEnd","composeDoc","isEmpty","hexDigits","tagChars","flowIndicatorChars","invalidAnchorChars","isNotAnchorChar","Lexer","atEnd","blockScalarIndent","blockScalarKeep","flowKey","flowLevel","indentNext","indentValue","lineEndPos","incomplete","hasChars","parseNext","atLineEnd","charAt","continueScalar","dt","getLine","setNext","state","peek","parseStream","parseLineStart","parseBlockStart","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","pushCount","dirEnd","pushSpaces","pushNewline","sp","ch0","ch1","pushIndicators","pushUntil","quote","qb","pushToIndex","lastChar","allowEmpty","pushTag","allowTabs","LineCounter","low","high","mid","includesToken","list","findNonEmptyIndex","isFlowToken","getPrevProps","getFirstKeyStartProps","fixFlowSeqItems","onNewLine","atNewLine","atScalar","onKeyLine","stack","lexer","lexeme","lex","step","tokenType","pop","sourceToken","top","stream","document","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","lineEnd","bv","startBlockValue","atIndentedComment","_prev$value","atMapIndent","atNextItem","fs","flowScalar","_prev$value2"],"mappings":"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"}