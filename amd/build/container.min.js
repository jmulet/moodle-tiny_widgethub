define("tiny_widgethub/container",["exports"],(function(_exports){function isClass(obj){var _obj$constructor,_obj$constructor$toSt,_obj$prototype,_obj$prototype$constr,_obj$prototype$constr2;const isCtorClass="class"===(null===(_obj$constructor=obj.constructor)||void 0===_obj$constructor||null===(_obj$constructor$toSt=_obj$constructor.toString())||void 0===_obj$constructor$toSt?void 0:_obj$constructor$toSt.substring(0,5));if(void 0===obj.prototype)return isCtorClass;const isPrototypeCtorClass="class"===(null===(_obj$prototype=obj.prototype)||void 0===_obj$prototype||null===(_obj$prototype$constr=_obj$prototype.constructor)||void 0===_obj$prototype$constr||null===(_obj$prototype$constr2=_obj$prototype$constr.toString())||void 0===_obj$prototype$constr2?void 0:_obj$prototype$constr2.substring(0,5));return isCtorClass||isPrototypeCtorClass}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.DIContainer=void 0;class DIContainer{static clear(){DIContainer.#containerInstances=new Map,DIContainer.#registry=new Map,DIContainer.#singletonInstances=new Map}static#containerInstances=new Map;static#registry=new Map;static#singletonInstances=new Map;#serviceInstances=new Map;static init(editor){let instance=DIContainer.#containerInstances.get(editor);return instance||(instance=new DIContainer,instance.registerInstance("editor",editor),DIContainer.#containerInstances.set(editor,instance)),instance}static#parseDeps(dependencies){return null!=dependencies&&dependencies.trim()?dependencies.split(",").map((e=>e.trim())):[]}static registerSingleton(name,obj,dependencies){this.#registry.set(name,{name:name,type:"singleton",obj:obj,deps:DIContainer.#parseDeps(dependencies)})}static registerService(name,obj,dependencies){this.#registry.set(name,{name:name,type:"service",obj:obj,deps:DIContainer.#parseDeps(dependencies)})}static registerFactory(name,obj,dependencies){this.#registry.set(name,{name:name,type:"factory",obj:obj,deps:DIContainer.#parseDeps(dependencies)})}registerInstance(name,obj){this.#serviceInstances.set(name,obj)}static get(name,path){if(path=path||[],name.indexOf(",")>0)return name.split(",").map((e=>DIContainer.get(e.trim(),path)));if(path.indexOf(name)>=0)throw new Error(`Circular dependency detected on ${name}`);path.push(name);const reg=DIContainer.#registry.get(name);if(!reg)throw new Error(`Cannot find a registry for dependency ${name}`);if("singleton"!==reg.type)throw new Error(`Non singleton dependency ${name} must be invoked from an instance of the container.`);if(DIContainer.#singletonInstances.has(reg.name))return DIContainer.#singletonInstances.get(reg.name);const deps=(reg.deps??[]).map((name=>DIContainer.get(name,path)));let resolved;return resolved=isClass(reg.obj)?new reg.obj(...deps):"function"==typeof reg.obj&&deps.length?reg.obj(...deps):reg.obj,DIContainer.#singletonInstances.set(name,resolved),resolved}get(name,path){if(path=path||[],name.indexOf(",")>0)return name.split(",").map((e=>this.get(e.trim(),path)));if(path.indexOf(name)>=0)throw new Error(`Circular dependency detected on ${name}`);if(path.push(name),this.#serviceInstances.has(name))return this.#serviceInstances.get(name);const reg=DIContainer.#registry.get(name);if(!reg)throw new Error(`Cannot find a registry for dependency ${name}`);switch(reg.type){case"singleton":return this.#getInstance(DIContainer.#singletonInstances,reg,path);case"service":return this.#getInstance(this.#serviceInstances,reg,path);case"factory":{const deps=(reg.deps??[]).map((name=>this.get(name,path)));if(isClass(reg.obj))return function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return new reg.obj(...deps,...args)};if("function"==typeof reg.obj)return function(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++)args[_key2]=arguments[_key2];return reg.obj(...deps,...args)}}}throw new Error(`Invalid registry type ${reg.type}`)}#getInstance(map,reg,path){if(map.has(reg.name))return map.get(reg.name);const instance=this.#createInstance(reg,path);return map.set(reg.name,instance),instance}#createInstance(reg,path){const deps=(reg.deps??[]).map((name=>this.get(name,path)));return isClass(reg.obj)?new reg.obj(...deps):"function"==typeof reg.obj&&deps.length?reg.obj(...deps):reg.obj}}_exports.DIContainer=DIContainer}));

//# sourceMappingURL=container.min.js.map