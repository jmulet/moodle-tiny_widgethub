{"version":3,"file":"widgetproperties_ctrl.min.js","sources":["../../src/controller/widgetproperties_ctrl.js"],"sourcesContent":["/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getFormCtrl} from '../controller/form_ctrl';\nimport {getModalSrv} from '../service/modal_service';\nimport {createBinding} from '../util';\n\n/**\n * @typedef {JQuery<HTMLElement>} ModalDialogue\n * @property {JQuery<HTMLElement>} header\n * @property {JQuery<HTMLElement>} body\n * @property {JQuery<HTMLElement>} footer\n * @property {() => void} destroy\n * @property {() => void} show\n */\n\n/**\n * @class\n * @classdesc Defines a generic editor dialogue based on widget definition fields\n */\nexport class WidgetPropertiesCtrl {\n    /** @type {import('../service/modal_service').ModalDialogue | null} */\n    modal = null;\n\n    /**\n     * @param {import('../plugin').TinyMCE} editor\n     * @param {import('../controller/form_ctrl').FormCtrl} formCtrl\n     * @param {import('../service/modal_service').ModalSrv} modalSrv\n     **/\n    constructor(editor, formCtrl, modalSrv) {\n        /** @type {import('../plugin').TinyMCE} */\n        this.editor = editor;\n        /** @type {import('../controller/form_ctrl').FormCtrl} */\n        this.formCtrl = formCtrl;\n        /** @type {import('../service/modal_service').ModalSrv} */\n        this.modalSrv = modalSrv;\n    }\n\n    /**\n     * Displays a modal dialog for editing the currentContext\n     * based on contextual\n     * @param {import('../contextinit').PathResult} currentContext\n     * @returns\n     */\n    async show(currentContext) {\n        if (!currentContext.widget) {\n            console.error(\"Missing widget on currentContext\");\n            return;\n        }\n        const widget = currentContext.widget;\n        const hostId = this.editor.id;\n        // The DOM element for the root of the widget\n        const elem = currentContext.elem;\n\n        if (!elem || !widget?.hasBindings()) {\n            console.error(\"Invalid widget definition \", widget);\n            return;\n        }\n\n        // Create bindings\n        /** @type {Object.<string, any>} Empty object {} without prototype */\n        const bindingsDOM = Object.create(null);\n        // Extract param values from DOM\n        /** @type {Object.<string, any>} Empty object {} without prototype */\n        const paramValues = Object.create(null);\n        // Parameters that contain bindings\n        const parametersWithBindings = widget.parameters.filter(param => {\n            if (param.type === 'repeatable') {\n                const fieldsWithBindings = param.fields?.some(f => f.bind !== undefined);\n                return (fieldsWithBindings && param.item_selector !== undefined) || (typeof param.bind === 'object');\n            } else {\n                return param.bind != undefined;\n            }\n        });\n        parametersWithBindings.forEach((param) => {\n            if (param.bind && param.type !== 'repeatable') {\n                // A simple control binding\n                const binding = createBinding(param.bind, elem, typeof (param.value));\n                if (binding) {\n                    const pname = param.name;\n                    bindingsDOM[pname] = binding;\n                    paramValues[pname] = binding.getValue();\n                }\n            } else if (param.type === 'repeatable') {\n                if (typeof param.item_selector === 'string') {\n                    /** @type {any[]} */\n                    const lstValues = [];\n                    /** @type {Record<string, import('../util').Binding>[]} */\n                    const lstBindings = [];\n                    paramValues[param.name] = lstValues;\n                    bindingsDOM[param.name] = lstBindings;\n                    // Strategy 1. Searching DOM items and creating a binding per input\n                    // Find all item containers in DOM (param.bind is a query to every item element)\n                    elem.querySelectorAll(param.item_selector).forEach(itemRoot => {\n                        // For every field in parameter which has binding, create it\n                        /** @type {Record<string, any>} */\n                        const objValue = {};\n                        /** @type {Record<string, import('../util').Binding>} */\n                        const objBinding = {};\n                        param.fields?.filter(f => f.bind !== undefined).forEach(f => {\n                            // @ts-ignore\n                            const binding = createBinding(f.bind, itemRoot, typeof (f.value));\n                            if (binding) {\n                                objBinding[f.name] = binding;\n                                objValue[f.name] = binding.getValue();\n                            }\n                        });\n                        lstValues.push(objValue);\n                        lstBindings.push(objBinding);\n                    });\n                } else if (typeof param.bind === 'object') {\n                    // Strategy 2. A single binding for the whole array of objects\n                    const binding = createBinding(param.bind, elem);\n                    if (binding) {\n                        const pname = param.name;\n                        bindingsDOM[pname] = binding;\n                        paramValues[pname] = binding.getValue();\n                    }\n                }\n            }\n        });\n\n        // Create parameters form controls\n        /** @type {string[]} */\n        const controls = parametersWithBindings\n            .map(param => this.formCtrl.createControlHTML(hostId, param, paramValues[param.name]));\n\n        const ctxData = {\n            name: widget.name,\n            controls: controls\n        };\n\n        // Create the modal\n        // @ts-ignore\n        this.modal = await this.modalSrv.create('context', ctxData, () => {\n            this.modal?.destroy();\n            this.modal = null;\n        });\n        /** @type {import('../service/modal_service').ListenerTracker} */\n        const listenerTracker = (/** @type {Element}*/ el, /** @type {string} */ evType, /** @type {EventListener} */ handler) => {\n            this.modal?.twhRegisterListener(el, evType, handler);\n        };\n        const bodyElem = this.modal.body[0];\n        const formElem = this.modal.body.find('form')[0];\n        // Bind actions on image and color pickers\n        this.formCtrl.attachPickers(bodyElem, listenerTracker);\n        // Applying watchers to the form elements\n        this.formCtrl.applyFieldWatchers(bodyElem, paramValues, widget, false, listenerTracker);\n\n        // Bind accept action to modal\n        this.modal.footer.find(\"button.tiny_widgethub-btn-secondary\").on(\"click\", () => {\n            this.modal?.destroy();\n        });\n        this.modal.footer.find(\"button.tiny_widgethub-btn-primary\").on(\"click\", () => {\n            let updatedValues = paramValues;\n            if (formElem) {\n                updatedValues = this.formCtrl.extractFormParameters(widget, formElem, true);\n            }\n            this.modal?.destroy();\n            // Update parameter values back to DOM\n            Object.keys(bindingsDOM).forEach(key => {\n                const val = updatedValues[key];\n                if (val === undefined) {\n                    return;\n                }\n                if (Array.isArray(val) && Array.isArray(bindingsDOM[key])) {\n                    // eslint-disable-next-line max-len\n                    const zipped = val.map((v, i) => [v, bindingsDOM[key][i]]).slice(0, Math.min(val.length, bindingsDOM[key].length));\n                    // Follow stategy 1 for repeatable.\n                    for (const [valueObject, bindingObject] of zipped) {\n                        if (!valueObject || typeof valueObject !== 'object' ||\n                            !bindingObject || typeof bindingObject !== 'object') {\n                            continue;\n                        }\n                        Object.keys(valueObject).forEach(objKey => {\n                            bindingObject[objKey]?.setValue(valueObject[objKey]);\n                        });\n                    }\n                } else {\n                    // Regular binding or strategy 2 for repeatable.\n                    bindingsDOM[key]?.setValue(val);\n                }\n            });\n        });\n\n        // Help circles require popover\n        try {\n            // @ts-ignore\n            this.modal.body.popover({\n            container: \"body\",\n            selector: \"[data-toggle=popover][data-trigger=hover]\",\n            trigger: \"hover\"\n            });\n        } catch (ex) {\n            // console.error(ex);\n        }\n\n        this.modal.show();\n    }\n\n    close() {\n        this.modal?.destroy();\n    }\n}\n\nconst widgetPropertiesCtrlInstances = new Map();\n/**\n * @param {import('../plugin').TinyMCE} editor\n * @returns {WidgetPropertiesCtrl}\n */\nexport function getWidgetPropertiesCtrl(editor) {\n    let instance = widgetPropertiesCtrlInstances.get(editor);\n    if (!instance) {\n        instance = new WidgetPropertiesCtrl(editor, getFormCtrl(editor), getModalSrv());\n        widgetPropertiesCtrlInstances.set(editor, instance);\n    }\n    return instance;\n}\n"],"names":["editor","instance","widgetPropertiesCtrlInstances","get","WidgetPropertiesCtrl","set","modal","constructor","formCtrl","modalSrv","currentContext","widget","console","error","hostId","this","id","elem","hasBindings","bindingsDOM","Object","create","paramValues","parametersWithBindings","parameters","filter","param","type","fields","_param$fields","some","f","undefined","bind","item_selector","forEach","binding","value","pname","name","getValue","lstValues","lstBindings","querySelectorAll","itemRoot","objValue","objBinding","push","controls","map","createControlHTML","ctxData","destroy","listenerTracker","el","evType","handler","twhRegisterListener","bodyElem","body","formElem","find","attachPickers","applyFieldWatchers","footer","on","updatedValues","extractFormParameters","keys","key","val","Array","isArray","zipped","v","i","slice","Math","min","length","valueObject","bindingObject","objKey","setValue","popover","container","selector","trigger","ex","show","close","Map"],"mappings":"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"}