{"version":3,"file":"widgetPickerCtrl.min.js","sources":["../../src/controller/widgetPickerCtrl.js"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport { getWidgetParamsFactory } from '../controller/widgetParamsCtrl';\nimport { getEditorOptions } from '../options';\nimport { getModalSrv } from '../service/modalSrv';\nimport { getTemplateSrv } from '../service/templateSrv';\nimport { getUserStorage } from '../service/userStorageSrv';\nimport {genID, hashCode, searchComp} from '../util';\n\n/**\n * Convert a simple input element in a typeahead widget\n */\nclass TypeAheadInput {\n    _inputElem;\n    _listener;\n    /** @type {number | undefined} */\n    _sfTimeout;\n    /**\n     * @param {HTMLElement} inputElem\n     * @param {Function} callback\n     * @param {number=} delay\n     */\n    constructor(inputElem, callback, delay) {\n        this._inputElem = inputElem;\n        this._listener = () => {\n            if (this._sfTimeout) {\n                window.clearTimeout(this._sfTimeout);\n                this._sfTimeout = undefined;\n            }\n            this._sfTimeout = window.setTimeout(() => callback(), delay ?? 800);\n        };\n        this._inputElem.addEventListener('keyup', this._listener);\n    }\n    off() {\n        if (this._sfTimeout) {\n            window.clearTimeout(this._sfTimeout);\n            this._sfTimeout = undefined;\n        }\n        if (this._listener) {\n            this._inputElem.removeEventListener('keyup', this._listener);\n        }\n    }\n}\n\n/**\n * @param {HTMLElement} el\n * @param {boolean} visible\n */\nconst toggleVisible = function(el, visible) {\n    if (visible) {\n        el.classList.remove(\"tiny_widgethub-hidden\");\n    } else {\n        el.classList.add(\"tiny_widgethub-hidden\");\n    }\n};\n\nconst Templates = {\n    RECENT_SNPT: `<div style=\"margin:10px 45px;font-size:85%;\">{{#recent}} \n    {{#name}}<a href=\"javascript:void(0)\" data-key=\"{{key}}\"><span class=\"badge badge-secondary\">{{name}}</span></a>{{/name}}\n    {{/recent}}`\n};\n\nexport class WidgetPickerCtrl {\n    /**\n     * @param {import('../plugin').TinyMCE} editor\n     * @param {import('../options').EditorOptions} editorOptions\n     * @param {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} widgetParamsFactory\n     * @param {import('../service/modalSrv').ModalSrv} modalSrv\n     * @param {import('../service/templateSrv').TemplateSrv} templateSrv\n     * @param {import('../service/userStorageSrv').UserStorageSrv} userStorage\n     */\n    constructor(editor, editorOptions, widgetParamsFactory, modalSrv, templateSrv, userStorage) {\n        /** @type {import('../plugin').TinyMCE} */\n        this.editor = editor;\n        /** @type {import('../options').EditorOptions} */\n        this.editorOptions = editorOptions;\n        /** @type {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} */\n        this.widgetParamsFactory = widgetParamsFactory;\n        /** @type {import('../service/modalSrv').ModalSrv} */\n        this.modalSrv = modalSrv;\n        /** @type {import('../service/templateSrv').TemplateSrv} */\n        this.templateSrv = templateSrv;\n        /** @type {import('../service/userStorageSrv').UserStorageSrv} */\n        this.storage = userStorage;\n    }\n\n    show() {\n        this.modal?.show();\n    }\n\n    async handleAction() {\n        // Type on search input\n        const selectMode = this.editor.selection.getContent().trim().length > 0;\n\n        const onSearchKeyup = () => {\n            let numshown = 0;\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            const searchText = (widgetSearchElem.value || '');\n            this.storage.setToSession('searchtext', searchText, true);\n            /** @type {NodeListOf<HTMLElement>} */\n            const allbtns = document.querySelectorAll(\".tiny_widgethub-buttons\");\n            /** @type {NodeListOf<HTMLElement>} */\n            const allcatgs = document.querySelectorAll(\".tiny_widgethub-category\");\n\n            // Are we in selectMode, does the widget support it? insertquery\n            if (!searchText) {\n                allbtns.forEach(\n                    (el) => {\n                    const visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            } else {\n                allbtns.forEach((el) => {\n                    let visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    const el2 = el.querySelector('button');\n                    visible = visible && searchComp(el2?.title + \"\", searchText);\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            }\n            allcatgs.forEach((el) => {\n                const count = el.querySelectorAll(\".tiny_widgethub-buttons:not(.tiny_widgethub-hidden)\").length;\n                toggleVisible(el, count > 0);\n            });\n            console.log(\"Num shown buttons is \", numshown);\n            // If no result show emptyList message\n            toggleVisible(this.modal.body.find(\".tiny_widgethub-emptylist\")[0], numshown == 0);\n        };\n\n\n        // Show modal with buttons.\n        if (this.modal) {\n            console.log(\"Estic en mode selecciÃ³? \" + selectMode);\n            if (selectMode) {\n                this.modal.header.find(\"span.ib-blink\").removeClass(\"tiny_widgethub-hidden\");\n            } else {\n                this.modal.header.find(\"span.ib-blink\").addClass(\"tiny_widgethub-hidden\");\n            }\n        } else {\n            const searchText = this.storage.getFromSession(\"searchtext\", \"\");\n            const data = this.getPickTemplateContext({\n                searchText: searchText\n            });\n            console.log(\" data  is  \", data);\n            // @ts-ignore\n            this.modal = await this.modalSrv.create('picker', data, () => {\n                this.modal.destroy();\n                this.modal = null;\n            });\n            // Event listeners.\n            // Click on clear text\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            widgetSearchElem.value = searchText;\n            this.modal.body.find(`#widget-clearfilter-btn${data.rid}`)[0].addEventListener('click', () => {\n                widgetSearchElem.value = \"\";\n                onSearchKeyup();\n            });\n            // Click on any widget button\n            this.modal.body[0].addEventListener('click',\n                /** @param {Event} event */\n                (event) => {\n                    this.handlePickModalClick(event);\n                });\n\n            this._typeAheadInput = new TypeAheadInput(widgetSearchElem, onSearchKeyup);\n        }\n\n        // Update the list of recently used widgets\n        const snptDict = this.editorOptions.widgetDict;\n        const recentWidgets = this.storage.getFromSession(\"recentsnpt\", \"\").split(\",\")\n            .filter((/** @type {string} **/ key) => key.trim())\n            .map((/** @type {string} **/ key) => {\n            const snpt = snptDict[key];\n            if (snpt) {\n                return {\n                    key: key,\n                    name: snpt.name\n                };\n            } else {\n                return {\n                    key: key,\n                    name: \"\"\n                };\n            }\n        });\n        let recentHTML = \"\";\n        if (recentWidgets.length) {\n            recentHTML = this.templateSrv.renderMustache(Templates.RECENT_SNPT, {recent: recentWidgets});\n        }\n        this.modal.body.find(\".tiny_widgethub-recent\").html(recentHTML);\n\n        this.modal.show();\n        onSearchKeyup();\n        setTimeout(() => {\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            widgetSearchElem.focus();\n        }, 400);\n    }\n\n    /**\n     * Get the template context for the dialogue.\n     *\n     * @param {Object.<string, any>=} data\n     * @returns {Object.<string, any>} data\n     */\n    getPickTemplateContext(data) {\n        const allButtons = Object.values(this.editorOptions.widgetDict);\n        /**\n         * @typedef {Object} Button\n         * @property {boolean} hidden\n         * @property {string} category\n         * @property {string} widgetkey\n         * @property {string} widgetname\n         * @property {string} widgettitle\n         * @property {string} iconname\n         * @property {boolean} disabled\n         * @property {boolean} selectable\n         * @property {string} widgetfawesome\n         */\n        /**\n         * @typedef {Object} Category\n         * @property {string} name\n         * @property {boolean} hidden\n         * @property {string} color\n         * @property {Button[]} buttons\n         */\n        /**\n         * @type {Object.<string, Category>}\n         **/\n        const categories = {};\n        allButtons.forEach(btn => {\n            const catName = btn.category.toUpperCase();\n            let found = categories[catName];\n            if (!found) {\n                const color = hashCode(catName) % 360;\n                let sat = '30%';\n                if (catName.toLowerCase() === 'obsolet') {\n                    sat = '0%'; // Gray\n                }\n                found = {\n                    name: catName,\n                    hidden: false,\n                    color: color + ', ' + sat,\n                    buttons: []\n                };\n                categories[catName] = found;\n            }\n            found.buttons.push({\n                    hidden: false,\n                    category: catName,\n                    widgetkey: btn.key,\n                    widgetname: btn.name,\n                    widgettitle: btn.name + \" \" + catName,\n                    iconname: \"fa fas fa-eye\",\n                    disabled: !btn.isUsableInScope(),\n                    selectable: btn.insertquery != null,\n                    widgetfawesome: \"\" // TODO\n            });\n        });\n        const categoriesList = Object.values(categories);\n        categoriesList.sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            }\n            if (a.name > b.name) {\n                return 1;\n            }\n            return 0;\n        });\n        categoriesList.forEach(cat => {\n            cat.buttons.sort();\n            cat.hidden = cat.buttons.filter(btn => !btn.hidden).length == 0;\n        });\n\n        return {rid: genID(),\n            selectMode: this.editor.selection.getContent().trim().length > 0,\n            elementid: this.editor.id,\n            categories: categoriesList, ...(data ?? {})};\n    }\n\n    /**\n     * Handle a click within the Modal.\n     *\n     * @param {Event} event The click event\n     */\n    async handlePickModalClick(event) {\n        /** @type {any} */\n        const target = event.target;\n        if (!target) {\n            return;\n        }\n        const button = target.closest('button.tiny_widgethub-btn');\n        const aRecent = target.closest('a[data-key]');\n        let widget = null;\n        if (button ?? aRecent) {\n            const selectedButton = (button ?? aRecent).dataset.key;\n            widget = this.editorOptions.widgetDict[selectedButton];\n        }\n        if (!widget) {\n            return;\n        }\n        // Must open a configuration dialogue for the current widget\n        let confirmMsg = null;\n        if (!widget.isUsableInScope()) {\n            confirmMsg = \"Aquest widget no Ã©s adequat per a la pÃ gina actual. Segur que voleu continuar?\";\n        }\n\n        if (confirmMsg) {\n            this.editor.windowManager.confirm(confirmMsg,\n            /** @param {*} state */\n            (state) => {\n                if (state) {\n                    this.handlePickModalAction(widget);\n                }\n            });\n        } else {\n            this.handlePickModalAction(widget);\n        }\n    }\n\n    /**\n     * @param {import('../options').Widget} widget\n     */\n    handlePickModalAction(widget) {\n        this.modal.hide();\n        const paramsController = this.widgetParamsFactory(widget);\n        // Keep reference to the calling parentCtrl\n        paramsController.parentCtrl = this;\n        // Decide whether to show the form or directly doInsert\n        if (widget.parameters.length === 0 && !widget.instructions) {\n            // Do insert directly\n            paramsController.insertWidget({});\n        } else {\n            paramsController.handleAction();\n        }\n    }\n}\n\nconst widgetPickerCtrlInstances = new Map();\n/**\n * @param {import('../plugin').TinyMCE} editor\n * @returns {WidgetPickerCtrl}\n */\nexport function getWidgetPickCtrl(editor) {\n    let instance = widgetPickerCtrlInstances.get(editor);\n    if (!instance) {\n        instance = new WidgetPickerCtrl(editor,\n            getEditorOptions(editor), getWidgetParamsFactory(editor),\n            getModalSrv(), getTemplateSrv(), getUserStorage(editor));\n        widgetPickerCtrlInstances.set(editor, instance);\n    }\n    return instance;\n}\n"],"names":["editor","instance","widgetPickerCtrlInstances","get","WidgetPickerCtrl","set","TypeAheadInput","_inputElem","_listener","_sfTimeout","constructor","inputElem","callback","delay","this","window","clearTimeout","undefined","setTimeout","addEventListener","off","removeEventListener","toggleVisible","el","visible","classList","remove","add","Templates","RECENT_SNPT","editorOptions","widgetParamsFactory","modalSrv","templateSrv","userStorage","storage","show","modal","selectMode","selection","getContent","trim","length","onSearchKeyup","numshown","searchText","body","find","value","setToSession","allbtns","document","querySelectorAll","allcatgs","forEach","dataset","selectable","el2","querySelector","title","count","console","log","header","removeClass","addClass","getFromSession","data","getPickTemplateContext","create","destroy","widgetSearchElem","rid","event","handlePickModalClick","_typeAheadInput","snptDict","widgetDict","recentWidgets","split","filter","key","map","snpt","name","recentHTML","renderMustache","recent","html","focus","allButtons","Object","values","categories","btn","catName","category","toUpperCase","found","color","sat","toLowerCase","hidden","buttons","push","widgetkey","widgetname","widgettitle","iconname","disabled","isUsableInScope","insertquery","widgetfawesome","categoriesList","sort","a","b","cat","elementid","id","target","button","closest","aRecent","widget","selectedButton","confirmMsg","windowManager","confirm","state","handlePickModalAction","hide","paramsController","parentCtrl","parameters","instructions","handleAction","insertWidget","Map"],"mappings":"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"}