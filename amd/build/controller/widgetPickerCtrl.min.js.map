{"version":3,"file":"widgetPickerCtrl.min.js","sources":["../../src/controller/widgetPickerCtrl.js"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport { getWidgetParamsFactory } from '../controller/widgetParamsCtrl';\nimport { getEditorOptions } from '../options';\nimport { getModalSrv } from '../service/modalSrv';\nimport { getTemplateSrv } from '../service/templateSrv';\nimport { getUserStorage } from '../service/userStorageSrv';\nimport {debounce, genID, hashCode, searchComp} from '../util';\n\n/**\n * @param {HTMLElement} el\n * @param {boolean} visible\n */\nconst toggleVisible = function(el, visible) {\n    if (visible) {\n        el.classList.remove(\"tiny_widgethub-hidden\");\n    } else {\n        el.classList.add(\"tiny_widgethub-hidden\");\n    }\n};\n\nexport class WidgetPickerCtrl {\n    /**\n     * @param {import('../plugin').TinyMCE} editor\n     * @param {import('../options').EditorOptions} editorOptions\n     * @param {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} widgetParamsFactory\n     * @param {import('../service/modalSrv').ModalSrv} modalSrv\n     * @param {import('../service/templateSrv').TemplateSrv} templateSrv\n     * @param {import('../service/userStorageSrv').UserStorageSrv} userStorage\n     */\n    constructor(editor, editorOptions, widgetParamsFactory, modalSrv, templateSrv, userStorage) {\n        /** @type {import('../plugin').TinyMCE} */\n        this.editor = editor;\n        /** @type {import('../options').EditorOptions} */\n        this.editorOptions = editorOptions;\n        /** @type {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} */\n        this.widgetParamsFactory = widgetParamsFactory;\n        /** @type {import('../service/modalSrv').ModalSrv} */\n        this.modalSrv = modalSrv;\n        /** @type {import('../service/templateSrv').TemplateSrv} */\n        this.templateSrv = templateSrv;\n        /** @type {import('../service/userStorageSrv').UserStorageSrv} */\n        this.storage = userStorage;\n\n        // Trigger preloading templates\n        this.modalSrv.create('picker', {});\n    }\n\n    show() {\n        this.modal?.show();\n    }\n\n    isSelectMode() {\n        return this.editor.selection.getContent().trim().length > 0;\n    }\n\n    async handleAction() {\n        // Type on search input\n        const selectMode = this.isSelectMode();\n\n        const onSearchKeyup = () => {\n            let numshown = 0;\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            const searchText = (widgetSearchElem.value || '');\n            this.storage.setToSession('searchtext', searchText, true);\n            /** @type {NodeListOf<HTMLElement>} */\n            const allbtns = document.querySelectorAll(\".tiny_widgethub-buttons\");\n            /** @type {NodeListOf<HTMLElement>} */\n            const allcatgs = document.querySelectorAll(\".tiny_widgethub-category\");\n\n            // Are we in selectMode, does the widget support it? insertquery\n            if (!searchText) {\n                allbtns.forEach(\n                    (el) => {\n                    const visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            } else {\n                allbtns.forEach((el) => {\n                    let visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    const el2 = el.querySelector('button');\n                    visible = visible && searchComp(el2?.title + \"\", searchText);\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            }\n            allcatgs.forEach((el) => {\n                const count = el.querySelectorAll(\".tiny_widgethub-buttons:not(.tiny_widgethub-hidden)\").length;\n                toggleVisible(el, count > 0);\n            });\n            console.log(\"Num shown buttons is \", numshown);\n            // If no result show emptyList message\n            toggleVisible(this.modal.body.find(\".tiny_widgethub-emptylist\")[0], numshown == 0);\n        };\n\n\n        // Show modal with buttons.\n        if (this.modal) {\n            console.log(\"Estic en mode selecció? \" + selectMode);\n            if (selectMode) {\n                this.modal.header.find(\"span.ib-blink\").removeClass(\"tiny_widgethub-hidden\");\n            } else {\n                this.modal.header.find(\"span.ib-blink\").addClass(\"tiny_widgethub-hidden\");\n            }\n        } else {\n            const searchText = this.storage.getFromSession(\"searchtext\", \"\");\n            const data = this.getPickTemplateContext({\n                searchText: searchText\n            });\n            console.log(\" data  is  \", data);\n            // @ts-ignore\n            this.modal = await this.modalSrv.create('picker', data, () => {\n                this.modal.destroy();\n                this.modal = null;\n            });\n\n            try {\n                this.modal.body.find(\".tiny_widgethub-categorycontainer\")\n                    .scrollspy('refresh');\n            } catch (ex) {\n                console.error(\"Problem setting scrollspy\", ex);\n            }\n\n            // Confiure preview panel\n            const previewPanel = this.modal.body.find(\"div.tiny_widgethub-preview\");\n            const widgetTable = this.editorOptions.widgetDict;\n\n            const mouseEnterDebounced = debounce(async(evt) => {\n                const key = evt.target?.dataset?.key ?? '';\n                const widget = widgetTable[key];\n                if (!widget || widget.isFilter()) {\n                    // Filters do not offer preview\n                    return;\n                }\n                /** @type {string | undefined} */\n                let html = widget._preview;\n                if (!html) {\n                    // Generate preview with default parameters\n                    html = await this.generatePreview(widget);\n                    widget._preview = html;\n                }\n                previewPanel.html(html);\n                previewPanel.css(\"display\", \"block\");\n            }, 1000);\n\n            const oMouseOut = () => {\n                mouseEnterDebounced.clear();\n                previewPanel.html('');\n                previewPanel.css(\"display\", \"none\");\n            };\n\n\n            // Event listeners.\n            // Click on clear text\n            const widgetSearchElem = this.modal.body.find(\"input\");\n            widgetSearchElem.val(searchText);\n            const debouncedKeyup = debounce(onSearchKeyup, 800);\n            widgetSearchElem.on('keyup', debouncedKeyup);\n\n            this.modal.body.find(`#widget-clearfilter-btn${data.rid}`).on('click', () => {\n                debouncedKeyup.clear();\n                widgetSearchElem.val(\"\");\n                widgetSearchElem.trigger(\"focus\");\n                onSearchKeyup();\n            });\n            // Click on any widget button (bubbles)\n            this.modal.body.find('div.tiny_widgethub-categorycontainer, div.tiny_widgethub-recent').on('click',\n                /** @param {Event} event */\n                (event) => {\n                    mouseEnterDebounced.clear();\n                    previewPanel.css(\"display\", \"none\");\n                    console.log(event.target);\n                    this.handlePickModalClick(event);\n                });\n            // Preview panel\n            this.modal.body.find(\".btn-group\")\n                .on(\"mouseenter\", mouseEnterDebounced)\n                .on(\"mouseout\", oMouseOut);\n        }\n\n        this.modal.show();\n        onSearchKeyup();\n        setTimeout(() => {\n            if (!this.modal?.body) {\n                return;\n            }\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            widgetSearchElem.focus();\n        }, 400);\n    }\n\n    /**\n     * Get the template context for the dialogue.\n     *\n     * @param {Object.<string, any>=} data\n     * @returns {Object.<string, any>} data\n     */\n    getPickTemplateContext(data) {\n        const snptDict = this.editorOptions.widgetDict;\n        const allButtons = Object.values(snptDict);\n        /**\n         * @typedef {Object} Button\n         * @property {boolean} hidden\n         * @property {string} category\n         * @property {string} widgetkey\n         * @property {string} widgetname\n         * @property {string} widgettitle\n         * @property {string} iconname\n         * @property {boolean} disabled\n         * @property {boolean} selectable\n         * @property {string} widgetfawesome\n         */\n        /**\n         * @typedef {Object} Category\n         * @property {string} name\n         * @property {boolean} hidden\n         * @property {string} color\n         * @property {Button[]} buttons\n         */\n        /**\n         * @type {Object.<string, Category>}\n         **/\n        const categories = {};\n        allButtons.forEach(btn => {\n            const catName = (btn.category ?? 'MISC').toUpperCase();\n            let found = categories[catName];\n            if (!found) {\n                const color = hashCode(catName) % 360;\n                let sat = '30%';\n                if (catName.toLowerCase().startsWith('obsolet')) {\n                    sat = '0%'; // Gray\n                }\n                found = {\n                    name: catName,\n                    hidden: false,\n                    color: color + ', ' + sat,\n                    buttons: []\n                };\n                categories[catName] = found;\n            }\n            found.buttons.push({\n                hidden: false,\n                category: catName,\n                widgetindex: btn.id,\n                widgetkey: btn.key,\n                widgetname: btn.name,\n                widgettitle: btn.name + \" \" + catName,\n                iconname: \"fa fas fa-eye\",\n                disabled: btn.isUsableInScope(),\n                selectable: btn.insertquery != null,\n                widgetfawesome: \"\" // TODO\n            });\n        });\n        const categoriesList = Object.values(categories);\n        categoriesList.sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            }\n            if (a.name > b.name) {\n                return 1;\n            }\n            return 0;\n        });\n        categoriesList.forEach(cat => {\n            cat.buttons.sort();\n            cat.hidden = cat.buttons.filter(btn => !btn.hidden).length == 0;\n        });\n\n         // Update the list of recently used widgets\n        const recentList = this.storage.getRecentUsed().filter((/** @type {any} **/ recent) => {\n                // In select mode must filter widgets that do support it\n                const key = recent.key;\n                const widget = snptDict[key];\n                if (!widget) {\n                    return false;\n                }\n                const selectable = widget.insertquery !== undefined;\n                const isSelection = this.isSelectMode();\n                return key.length > 0 && (!isSelection || (isSelection && selectable));\n             })\n             .map((/** @type {any} **/ recent) => {\n                const key = recent.key;\n                 const snpt = snptDict[key];\n                 if (snpt) {\n                     return {\n                         key: key,\n                         name: snpt.name\n                     };\n                 } else {\n                     return {\n                         key: key,\n                         name: \"\"\n                     };\n                 }\n             });\n\n        return {\n            rid: genID(),\n            selectMode: this.isSelectMode(),\n            elementid: this.editor.id,\n            categories: categoriesList, ...(data ?? {}),\n            recent: recentList\n        };\n    }\n\n    /**\n     * Handle a click within the Modal.\n     *\n     * @param {Event} event The click event\n     */\n    async handlePickModalClick(event) {\n        /** @type {any} */\n        const target = event.target;\n        if (!target) {\n            return;\n        }\n        const button = target.closest('button.tiny_widgethub-btn');\n        const aRecent = target.closest('a[data-key]');\n        let widget = null;\n        if (button ?? aRecent) {\n            const selectedButton = (button ?? aRecent).dataset.key;\n            widget = this.editorOptions.widgetDict[selectedButton];\n        }\n        if (!widget) {\n            return;\n        }\n        // Must open a configuration dialogue for the current widget\n        let confirmMsg = null;\n        if (!widget.isUsableInScope()) {\n            confirmMsg = \"Aquest widget no és adequat per a la pàgina actual. Segur que voleu continuar?\";\n        }\n\n        if (confirmMsg) {\n            this.editor.windowManager.confirm(confirmMsg,\n            /** @param {*} state */\n            (state) => {\n                if (state) {\n                    this.handlePickModalAction(widget);\n                }\n            });\n        } else {\n            this.handlePickModalAction(widget);\n        }\n    }\n\n    /**\n     * @param {import('../options').Widget} widget\n     */\n    handlePickModalAction(widget) {\n        this.modal.hide();\n        const paramsController = this.widgetParamsFactory(widget);\n        // Keep reference to the calling parentCtrl\n        paramsController.parentCtrl = this;\n        // Decide whether to show the form or directly doInsert\n        if (widget.parameters.length === 0 && !widget.instructions) {\n            // Do insert directly\n            paramsController.insertWidget({});\n        } else {\n            paramsController.handleAction();\n        }\n    }\n}\n\nconst widgetPickerCtrlInstances = new Map();\n/**\n * @param {import('../plugin').TinyMCE} editor\n * @returns {WidgetPickerCtrl}\n */\nexport function getWidgetPickCtrl(editor) {\n    let instance = widgetPickerCtrlInstances.get(editor);\n    if (!instance) {\n        instance = new WidgetPickerCtrl(editor,\n            getEditorOptions(editor), getWidgetParamsFactory(editor),\n            getModalSrv(), getTemplateSrv(), getUserStorage(editor));\n        widgetPickerCtrlInstances.set(editor, instance);\n    }\n    return instance;\n}\n"],"names":["editor","instance","widgetPickerCtrlInstances","get","WidgetPickerCtrl","set","toggleVisible","el","visible","classList","remove","add","constructor","editorOptions","widgetParamsFactory","modalSrv","templateSrv","userStorage","storage","create","show","modal","isSelectMode","this","selection","getContent","trim","length","selectMode","onSearchKeyup","numshown","searchText","body","find","value","setToSession","allbtns","document","querySelectorAll","allcatgs","forEach","dataset","selectable","el2","querySelector","title","count","console","log","header","removeClass","addClass","getFromSession","data","getPickTemplateContext","destroy","scrollspy","ex","error","previewPanel","widgetTable","widgetDict","mouseEnterDebounced","async","key","evt","target","widget","isFilter","html","_preview","generatePreview","css","oMouseOut","clear","widgetSearchElem","val","debouncedKeyup","on","rid","trigger","event","handlePickModalClick","setTimeout","_this$modal2","focus","snptDict","allButtons","Object","values","categories","btn","catName","category","toUpperCase","found","color","sat","toLowerCase","startsWith","name","hidden","buttons","push","widgetindex","id","widgetkey","widgetname","widgettitle","iconname","disabled","isUsableInScope","insertquery","widgetfawesome","categoriesList","sort","a","b","cat","filter","recentList","getRecentUsed","recent","undefined","isSelection","map","snpt","elementid","button","closest","aRecent","selectedButton","confirmMsg","windowManager","confirm","state","handlePickModalAction","hide","paramsController","parentCtrl","parameters","instructions","handleAction","insertWidget","Map"],"mappings":"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"}