{"version":3,"file":"widgetPickerCtrl.min.js","sources":["../../src/controller/widgetPickerCtrl.js"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {getWidgetParamsFactory} from '../controller/widgetParamsCtrl';\nimport {getEditorOptions, getWidgetDict} from '../options';\nimport {getModalSrv} from '../service/modalSrv';\nimport {getTemplateSrv} from '../service/templateSrv';\nimport {getUserStorage} from '../service/userStorageSrv';\nimport {debounce, genID, hashCode, searchComp, toggleClass} from '../util';\n\n/**\n * @param {HTMLElement} el\n * @param {boolean} visible\n */\nconst toggleVisible = function(el, visible) {\n    if (visible) {\n        el.classList.remove(\"tiny_widgethub-hidden\");\n    } else {\n        el.classList.add(\"tiny_widgethub-hidden\");\n    }\n};\n\nexport class WidgetPickerCtrl {\n    /** @type {import('../service/modalSrv').ModalDialogue} */\n    // @ts-ignore\n    modal;\n\n    /**\n     * @param {import('../plugin').TinyMCE} editor\n     * @param {import('../options').EditorOptions} editorOptions\n     * @param {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} widgetParamsFactory\n     * @param {import('../service/modalSrv').ModalSrv} modalSrv\n     * @param {import('../service/templateSrv').TemplateSrv} templateSrv\n     * @param {import('../service/userStorageSrv').UserStorageSrv} userStorage\n     */\n    constructor(editor, editorOptions, widgetParamsFactory, modalSrv, templateSrv, userStorage) {\n        /** @type {import('../plugin').TinyMCE} */\n        this.editor = editor;\n        /** @type {import('../options').EditorOptions} */\n        this.editorOptions = editorOptions;\n        /** @type {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} */\n        this.widgetParamsFactory = widgetParamsFactory;\n        /** @type {import('../service/modalSrv').ModalSrv} */\n        this.modalSrv = modalSrv;\n        /** @type {import('../service/templateSrv').TemplateSrv} */\n        this.templateSrv = templateSrv;\n        /** @type {import('../service/userStorageSrv').UserStorageSrv} */\n        this.storage = userStorage;\n        /** @type {number} */\n        this.scrollPos = 0;\n    }\n\n    show() {\n        this.modal?.show();\n    }\n\n    isSelectMode() {\n        return this.editor.selection.getContent().trim().length > 0;\n    }\n\n     // Type on search input\n    onSearchKeyup() {\n        const selectMode = this.isSelectMode();\n        let numshown = 0;\n        const widgetSearchElem = this.modal.body.find(\"input\")[0];\n        const searchText = (widgetSearchElem.value || '');\n        this.storage.setToSession('searchtext', searchText, true);\n        /** @type {NodeListOf<HTMLElement>} */\n        const allbtns = document.querySelectorAll(\".btn-group\");\n        /** @type {NodeListOf<HTMLElement>} */\n        const allcatgs = document.querySelectorAll(\".tiny_widgethub-category\");\n\n        // Are we in selectMode, does the widget support it? insertquery\n        if (!searchText) {\n            allbtns.forEach(\n                (el) => {\n                const visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                toggleVisible(el, visible);\n                if (visible) {\n                    numshown++;\n                }\n            });\n        } else {\n            allbtns.forEach((el) => {\n                let visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                const el2 = el.querySelector('button');\n                visible = visible && searchComp(el2?.title + \"\", searchText);\n                toggleVisible(el, visible);\n                if (visible) {\n                    numshown++;\n                }\n            });\n        }\n        allcatgs.forEach((el) => {\n            const count = el.querySelectorAll(\".btn-group:not(.tiny_widgethub-hidden)\").length;\n            toggleVisible(el, count > 0);\n        });\n        console.log(\"Num shown buttons is \", numshown);\n        // If no result show emptyList message\n        toggleVisible(this.modal.body.find(\".tiny_widgethub-emptylist\")[0], numshown == 0);\n    }\n\n    async createModal() {\n        const searchText = this.storage.getFromSession(\"searchtext\", \"\");\n        const data = this.getPickTemplateContext({\n            searchText: searchText\n        });\n        console.log(\" data  is  \", data);\n        // @ts-ignore\n        this.modal = await this.modalSrv.create('picker', data);\n\n        try {\n            this.modal.body.find(\".tiny_widgethub-categorycontainer\")\n                // @ts-ignore\n                .scrollspy('refresh');\n        } catch (ex) {\n            console.error(\"Problem setting scrollspy\", ex);\n        }\n\n        // Confiure preview panel\n        const previewPanel = this.modal.body.find(\"div.tiny_widgethub-preview\");\n        const widgetTable = this.editorOptions.widgetDict;\n\n        const mouseEnterDebounced = debounce(async(/** @type {*} */ evt) => {\n            const key = evt.target?.closest('.btn-group')?.dataset?.key ?? '';\n            const widget = widgetTable[key];\n            if (!widget || widget.isFilter()) {\n                // Filters do not offer preview\n                return;\n            }\n            /** @type {string | undefined} */\n            let html = widget._preview;\n            if (!html) {\n                // Generate preview with default parameters\n                html = await this.generatePreview(widget);\n                widget._preview = html;\n            }\n            previewPanel.html(html);\n            previewPanel.css(\"display\", \"block\");\n        }, 1000);\n\n        const onMouseOut = () => {\n            mouseEnterDebounced.clear();\n            previewPanel.html('');\n            previewPanel.css(\"display\", \"none\");\n        };\n\n\n        // Event listeners.\n        // Click on clear text\n        const widgetSearchElem = this.modal.body.find(\"input\");\n        widgetSearchElem.val(searchText);\n        const debouncedKeyup = debounce(this.onSearchKeyup.bind(this), 800);\n        widgetSearchElem.on('keyup', debouncedKeyup);\n\n        this.modal.body.find(`#widget-clearfilter-btn${data.rid}`).on('click', () => {\n            debouncedKeyup.clear();\n            widgetSearchElem.val(\"\");\n            widgetSearchElem.trigger(\"focus\");\n            this.onSearchKeyup();\n        });\n        // Click on any widget button (bubbles)\n        this.modal.body.find('div.tiny_widgethub-categorycontainer, div.tiny_widgethub-recent').on('click',\n            /** @param {Event} event */\n            (event) => {\n                mouseEnterDebounced.clear();\n                previewPanel.css(\"display\", \"none\");\n                console.log(event.target);\n                this.handlePickModalClick(event);\n            });\n\n        // Preview panel\n        this.modal.body.find(\".btn-group\")\n            .on(\"mouseenter\", mouseEnterDebounced)\n            .on(\"mouseout\", onMouseOut);\n\n        // Store current scroll\n        const scrollPane = this.modal.body.find('.tiny_widgethub-categorycontainer');\n        scrollPane.on('scroll', debounce(() => {\n            this.scrollPos = Math.round(scrollPane.scrollTop() ?? 0);\n        }, 100));\n    }\n\n\n    async handleAction() {\n        this.storage.loadStore();\n\n        if (!this.modal) {\n            // Create the modal if not exists.\n            await this.createModal();\n        } else {\n            // Update list of recent\n            const widgetDict = getWidgetDict(this.editor);\n            const html = this.storage.getRecentUsed()\n               .filter(r => widgetDict[r.key] !== undefined)\n               .map(r =>\n                `<a href=\"javascript:void(0)\" data-key=\"${r.key}\" data-insert=\"recent\"><span class=\"badge badge-secondary\">${widgetDict[r.key].name}</span></a>`)\n               .join('\\n');\n               this.modal.body.find('.tiny_widgethub-recent').html(html);\n        }\n\n        const selectMode = this.isSelectMode();\n        console.log(\"Estic en mode selecció? \" + selectMode);\n        if (selectMode) {\n            this.modal.header.find(\"span.ib-blink\").removeClass(\"tiny_widgethub-hidden\");\n        } else {\n            this.modal.header.find(\"span.ib-blink\").addClass(\"tiny_widgethub-hidden\");\n        }\n\n        this.modal.show();\n\n        setTimeout(() => {\n            if (!this.modal?.body) {\n                return;\n            }\n            if (this.scrollPos > 0) {\n                console.log(\"Setting scroll to \", this.scrollPos);\n                this.modal.body.find('.tiny_widgethub-categorycontainer').scrollTop(this.scrollPos);\n            }\n            this.modal.body.find(\"input\").trigger('focus');\n        }, 200);\n    }\n\n    /**\n     * @param {import('../options').Widget} widget\n     * @returns {Promise<string>}\n     */\n    generatePreview(widget) {\n        const toInterpolate = {...widget.defaults};\n        // Decide which template engine to use\n        const engine = widget.prop('engine');\n        return this.templateSrv.render(widget.template ?? \"\", toInterpolate, widget.I18n, engine);\n    }\n    /**\n     * Get the template context for the dialogue.\n     *\n     * @param {Object.<string, any>=} data\n     * @returns {Object.<string, any>} data\n     */\n    getPickTemplateContext(data) {\n        const snptDict = this.editorOptions.widgetDict;\n        const allButtons = Object.values(snptDict);\n        /**\n         * @typedef {Object} Button\n         * @property {boolean} hidden\n         * @property {string} category\n         * @property {number} widgetindex\n         * @property {string} widgetkey\n         * @property {string} widgetname\n         * @property {string} widgettitle\n         * @property {string} iconname\n         * @property {boolean} disabled\n         * @property {boolean} selectable\n         * @property {boolean} isfilter\n         * @property {boolean} filterset\n         */\n        /**\n         * @typedef {Object} Category\n         * @property {string} name\n         * @property {boolean} hidden\n         * @property {string} color\n         * @property {Button[]} buttons\n         */\n        // Parse filters that are autoset by the user.\n        const autoFilters = this.storage.getFromLocal(\"startup.filters\", \"\")\n            .split(\",\").map(f => f.trim());\n        /**\n         * @type {Object.<string, Category>}\n         **/\n        const categories = {};\n        allButtons.forEach(btn => {\n            const isFilter = btn.isFilter();\n            const catName = (btn.category ?? 'MISC').toUpperCase();\n            let found = categories[catName];\n            if (!found) {\n                const color = hashCode(catName) % 360;\n                let sat = '30%';\n                if (catName.toLowerCase().startsWith('obsolet')) {\n                    sat = '0%'; // Gray\n                }\n                found = {\n                    name: catName,\n                    hidden: false,\n                    color: color + ', ' + sat,\n                    buttons: []\n                };\n                categories[catName] = found;\n            }\n            found.buttons.push({\n                hidden: false,\n                category: catName,\n                widgetindex: btn.id,\n                widgetkey: btn.key,\n                widgetname: btn.name,\n                widgettitle: btn.name + \" \" + catName,\n                iconname: \"fa fas fa-eye\",\n                disabled: !btn.isUsableInScope(),\n                selectable: btn.insertquery != null,\n                isfilter: isFilter,\n                filterset: isFilter && autoFilters.includes(btn.key)\n            });\n        });\n        const categoriesList = Object.values(categories);\n        categoriesList.sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            }\n            if (a.name > b.name) {\n                return 1;\n            }\n            return 0;\n        });\n        categoriesList.forEach(cat => {\n            cat.buttons.sort();\n            cat.hidden = cat.buttons.filter(btn => !btn.hidden).length == 0;\n        });\n\n         // Update the list of recently used widgets\n        const recentList = this.storage.getRecentUsed().filter((/** @type {any} **/ recent) => {\n                // In select mode must filter widgets that do support it\n                const key = recent.key;\n                const widget = snptDict[key];\n                if (!widget) {\n                    return false;\n                }\n                const selectable = widget.insertquery !== undefined;\n                const isSelection = this.isSelectMode();\n                return key.length > 0 && (!isSelection || (isSelection && selectable));\n             })\n             .map((/** @type {any} **/ recent) => {\n                const key = recent.key;\n                 const snpt = snptDict[key];\n                 if (snpt) {\n                     return {\n                         key: key,\n                         name: snpt.name\n                     };\n                 } else {\n                     return {\n                         key: key,\n                         name: \"\"\n                     };\n                 }\n             });\n\n        return {\n            rid: genID(),\n            selectMode: this.isSelectMode(),\n            elementid: this.editor.id,\n            categories: categoriesList, ...(data ?? {}),\n            recent: recentList\n        };\n    }\n\n    /**\n     * Handle a click within the Modal.\n     *\n     * @param {Event} event The click event\n     */\n    async handlePickModalClick(event) {\n        /** @type {any} */\n        const target = event.target;\n        if (!target) {\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const buttonWrapper = target.closest('[data-key]');\n        /** @type {import('../options').Widget | null} */\n        let widget = null;\n        if (buttonWrapper) {\n            const selectedButton = buttonWrapper?.dataset?.key;\n            if (selectedButton) {\n                widget = this.editorOptions.widgetDict[selectedButton];\n            }\n        }\n        if (!widget) {\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const button = target.closest('button.btn');\n        // Check if it is a toggle button to autoset a filter\n        if (button?.dataset?.auto) {\n            const isSet = button.dataset.auto !== \"true\";\n            button.dataset.auto = isSet + '';\n            toggleClass(button, 'btn-primary', 'btn-outline-primary');\n            const key = widget.key;\n            // Persist option\n            const autoFilters = new Set(this.storage.getFromLocal('startup.filters', '').split(''));\n            if (isSet) {\n                autoFilters.add(key);\n            } else {\n                autoFilters.delete(key);\n            }\n            this.storage.setToLocal('startup.filters', [...autoFilters].join(\",\"), true);\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const aRecent = target.closest('a[data-key]');\n        // If it is a recently used widget, recover the used parameters\n        /** @type {Record<string, any> | undefined} */\n        let ctx;\n        if (aRecent) {\n            ctx = this.storage.getRecentUsed().filter(e => e.key === widget.key)[0]?.p;\n        }\n        // Must open a configuration dialogue for the current widget\n        let confirmMsg = null;\n        if (!widget.isUsableInScope()) {\n            confirmMsg = \"Aquest widget no és adequat per a la pàgina actual. Segur que voleu continuar?\";\n        }\n\n        const forceInsert = aRecent !== null || button?.dataset?.insert === 'true';\n        if (confirmMsg) {\n            this.editor.windowManager.confirm(confirmMsg,\n            /** @param {*} state */\n            (state) => {\n                if (state) {\n                    this.handlePickModalAction(widget, forceInsert, ctx);\n                }\n            });\n        } else {\n            this.handlePickModalAction(widget, forceInsert, ctx);\n        }\n    }\n\n    /**\n     * @param {import('../options').Widget} widget\n     * @param {boolean} [forceInsert]\n     * @param {Record<string, *>} [ctx]\n     */\n    handlePickModalAction(widget, forceInsert, ctx) {\n        this.modal?.hide();\n        const paramsController = this.widgetParamsFactory(widget);\n        // Keep reference to the calling parentCtrl\n        paramsController.parentCtrl = this;\n        // Decide whether to show the form or directly doInsert\n        if (forceInsert || (widget.parameters ?? []).length === 0 && !widget.instructions) {\n            // Do insert directly\n            paramsController.insertWidget(ctx ?? {});\n        } else {\n            paramsController.handleAction();\n        }\n    }\n}\n\nconst widgetPickerCtrlInstances = new Map();\n/**\n * @param {import('../plugin').TinyMCE} editor\n * @returns {WidgetPickerCtrl}\n */\nexport function getWidgetPickCtrl(editor) {\n    let instance = widgetPickerCtrlInstances.get(editor);\n    if (!instance) {\n        instance = new WidgetPickerCtrl(editor,\n            getEditorOptions(editor), getWidgetParamsFactory(editor),\n            getModalSrv(), getTemplateSrv(), getUserStorage(editor));\n        widgetPickerCtrlInstances.set(editor, instance);\n    }\n    return instance;\n}\n"],"names":["editor","instance","widgetPickerCtrlInstances","get","WidgetPickerCtrl","set","toggleVisible","el","visible","classList","remove","add","modal","constructor","editorOptions","widgetParamsFactory","modalSrv","templateSrv","userStorage","storage","scrollPos","show","isSelectMode","this","selection","getContent","trim","length","onSearchKeyup","selectMode","numshown","searchText","body","find","value","setToSession","allbtns","document","querySelectorAll","allcatgs","forEach","dataset","selectable","el2","querySelector","title","count","console","log","getFromSession","data","getPickTemplateContext","create","scrollspy","ex","error","previewPanel","widgetTable","widgetDict","mouseEnterDebounced","async","evt","key","target","closest","widget","isFilter","html","_preview","generatePreview","css","widgetSearchElem","val","debouncedKeyup","bind","on","rid","clear","trigger","event","handlePickModalClick","scrollPane","Math","round","scrollTop","loadStore","getRecentUsed","filter","r","undefined","map","name","join","createModal","header","removeClass","addClass","setTimeout","_this$modal2","toInterpolate","defaults","engine","prop","render","template","I18n","snptDict","allButtons","Object","values","autoFilters","getFromLocal","split","f","categories","btn","catName","category","toUpperCase","found","color","sat","toLowerCase","startsWith","hidden","buttons","push","widgetindex","id","widgetkey","widgetname","widgettitle","iconname","disabled","isUsableInScope","insertquery","isfilter","filterset","includes","categoriesList","sort","a","b","cat","recentList","recent","isSelection","snpt","elementid","buttonWrapper","selectedButton","_buttonWrapper$datase","button","_button$dataset","auto","isSet","Set","delete","setToLocal","aRecent","ctx","e","_this$storage$getRece","p","confirmMsg","forceInsert","insert","windowManager","confirm","state","handlePickModalAction","hide","paramsController","parentCtrl","parameters","instructions","insertWidget","handleAction","Map"],"mappings":"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"}