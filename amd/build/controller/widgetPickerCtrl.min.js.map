{"version":3,"file":"widgetPickerCtrl.min.js","sources":["../../src/controller/widgetPickerCtrl.js"],"sourcesContent":["/* eslint-disable max-len */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-console */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport {getWidgetParamsFactory} from '../controller/widgetParamsCtrl';\nimport {getEditorOptions} from '../options';\nimport {getModalSrv} from '../service/modalSrv';\nimport {getTemplateSrv} from '../service/templateSrv';\nimport {getUserStorage} from '../service/userStorageSrv';\nimport {debounce, genID, hashCode, searchComp, toggleClass} from '../util';\n\n/**\n * @param {HTMLElement} el\n * @param {boolean} visible\n */\nconst toggleVisible = function(el, visible) {\n    if (visible) {\n        el.classList.remove(\"tiny_widgethub-hidden\");\n    } else {\n        el.classList.add(\"tiny_widgethub-hidden\");\n    }\n};\n\nexport class WidgetPickerCtrl {\n    /**\n     * @param {import('../plugin').TinyMCE} editor\n     * @param {import('../options').EditorOptions} editorOptions\n     * @param {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} widgetParamsFactory\n     * @param {import('../service/modalSrv').ModalSrv} modalSrv\n     * @param {import('../service/templateSrv').TemplateSrv} templateSrv\n     * @param {import('../service/userStorageSrv').UserStorageSrv} userStorage\n     */\n    constructor(editor, editorOptions, widgetParamsFactory, modalSrv, templateSrv, userStorage) {\n        /** @type {import('../plugin').TinyMCE} */\n        this.editor = editor;\n        /** @type {import('../options').EditorOptions} */\n        this.editorOptions = editorOptions;\n        /** @type {(widget: import('../options').Widget) => import('../controller/widgetParamsCtrl').WidgetParamsCtrl} */\n        this.widgetParamsFactory = widgetParamsFactory;\n        /** @type {import('../service/modalSrv').ModalSrv} */\n        this.modalSrv = modalSrv;\n        /** @type {import('../service/templateSrv').TemplateSrv} */\n        this.templateSrv = templateSrv;\n        /** @type {import('../service/userStorageSrv').UserStorageSrv} */\n        this.storage = userStorage;\n    }\n\n    show() {\n        this.modal?.show();\n    }\n\n    isSelectMode() {\n        return this.editor.selection.getContent().trim().length > 0;\n    }\n\n    async handleAction() {\n        // Type on search input\n        const selectMode = this.isSelectMode();\n\n        const onSearchKeyup = () => {\n            let numshown = 0;\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            const searchText = (widgetSearchElem.value || '');\n            this.storage.setToSession('searchtext', searchText, true);\n            /** @type {NodeListOf<HTMLElement>} */\n            const allbtns = document.querySelectorAll(\".btn-group\");\n            /** @type {NodeListOf<HTMLElement>} */\n            const allcatgs = document.querySelectorAll(\".tiny_widgethub-category\");\n\n            // Are we in selectMode, does the widget support it? insertquery\n            if (!searchText) {\n                allbtns.forEach(\n                    (el) => {\n                    const visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            } else {\n                allbtns.forEach((el) => {\n                    let visible = !selectMode || (selectMode && el.dataset.selectable === \"true\");\n                    const el2 = el.querySelector('button');\n                    visible = visible && searchComp(el2?.title + \"\", searchText);\n                    toggleVisible(el, visible);\n                    if (visible) {\n                        numshown++;\n                    }\n                });\n            }\n            allcatgs.forEach((el) => {\n                const count = el.querySelectorAll(\".btn-group:not(.tiny_widgethub-hidden)\").length;\n                toggleVisible(el, count > 0);\n            });\n            console.log(\"Num shown buttons is \", numshown);\n            // If no result show emptyList message\n            toggleVisible(this.modal.body.find(\".tiny_widgethub-emptylist\")[0], numshown == 0);\n        };\n\n\n        // Show modal with buttons.\n        if (this.modal) {\n            console.log(\"Estic en mode selecció? \" + selectMode);\n            if (selectMode) {\n                this.modal.header.find(\"span.ib-blink\").removeClass(\"tiny_widgethub-hidden\");\n            } else {\n                this.modal.header.find(\"span.ib-blink\").addClass(\"tiny_widgethub-hidden\");\n            }\n        } else {\n            const searchText = this.storage.getFromSession(\"searchtext\", \"\");\n            const data = this.getPickTemplateContext({\n                searchText: searchText\n            });\n            console.log(\" data  is  \", data);\n            // @ts-ignore\n            this.modal = await this.modalSrv.create('picker', data, () => {\n                this.modal.destroy();\n                this.modal = null;\n            });\n\n            try {\n                this.modal.body.find(\".tiny_widgethub-categorycontainer\")\n                    .scrollspy('refresh');\n            } catch (ex) {\n                console.error(\"Problem setting scrollspy\", ex);\n            }\n\n            // Confiure preview panel\n            const previewPanel = this.modal.body.find(\"div.tiny_widgethub-preview\");\n            const widgetTable = this.editorOptions.widgetDict;\n\n            const mouseEnterDebounced = debounce(async(evt) => {\n                const key = evt.target?.dataset?.key ?? '';\n                const widget = widgetTable[key];\n                if (!widget || widget.isFilter()) {\n                    // Filters do not offer preview\n                    return;\n                }\n                /** @type {string | undefined} */\n                let html = widget._preview;\n                if (!html) {\n                    // Generate preview with default parameters\n                    html = await this.generatePreview(widget);\n                    widget._preview = html;\n                }\n                previewPanel.html(html);\n                previewPanel.css(\"display\", \"block\");\n            }, 1000);\n\n            const oMouseOut = () => {\n                mouseEnterDebounced.clear();\n                previewPanel.html('');\n                previewPanel.css(\"display\", \"none\");\n            };\n\n\n            // Event listeners.\n            // Click on clear text\n            const widgetSearchElem = this.modal.body.find(\"input\");\n            widgetSearchElem.val(searchText);\n            const debouncedKeyup = debounce(onSearchKeyup, 800);\n            widgetSearchElem.on('keyup', debouncedKeyup);\n\n            this.modal.body.find(`#widget-clearfilter-btn${data.rid}`).on('click', () => {\n                debouncedKeyup.clear();\n                widgetSearchElem.val(\"\");\n                widgetSearchElem.trigger(\"focus\");\n                onSearchKeyup();\n            });\n            // Click on any widget button (bubbles)\n            this.modal.body.find('div.tiny_widgethub-categorycontainer, div.tiny_widgethub-recent').on('click',\n                /** @param {Event} event */\n                (event) => {\n                    mouseEnterDebounced.clear();\n                    previewPanel.css(\"display\", \"none\");\n                    console.log(event.target);\n                    this.handlePickModalClick(event);\n                });\n            // Preview panel\n            this.modal.body.find(\".btn-group\")\n                .on(\"mouseenter\", mouseEnterDebounced)\n                .on(\"mouseout\", oMouseOut);\n        }\n\n        this.modal.show();\n        onSearchKeyup();\n        setTimeout(() => {\n            if (!this.modal?.body) {\n                return;\n            }\n            const widgetSearchElem = this.modal.body.find(\"input\")[0];\n            widgetSearchElem.focus();\n        }, 400);\n    }\n\n    /**\n     * Get the template context for the dialogue.\n     *\n     * @param {Object.<string, any>=} data\n     * @returns {Object.<string, any>} data\n     */\n    getPickTemplateContext(data) {\n        const snptDict = this.editorOptions.widgetDict;\n        const allButtons = Object.values(snptDict);\n        /**\n         * @typedef {Object} Button\n         * @property {boolean} hidden\n         * @property {string} category\n         * @property {string} widgetkey\n         * @property {string} widgetname\n         * @property {string} widgettitle\n         * @property {string} iconname\n         * @property {boolean} disabled\n         * @property {boolean} selectable\n         * @property {boolean} isfilter\n         * @property {boolean} filterset\n         */\n        /**\n         * @typedef {Object} Category\n         * @property {string} name\n         * @property {boolean} hidden\n         * @property {string} color\n         * @property {Button[]} buttons\n         */\n        // Parse filters that are autoset by the user.\n        const autoFilters = this.storage.getFromLocal(\"startup.filters\", \"\")\n            .split(\",\").map(f => f.trim());\n        /**\n         * @type {Object.<string, Category>}\n         **/\n        const categories = {};\n        allButtons.forEach(btn => {\n            const isFilter = btn.isFilter();\n            const catName = (btn.category ?? 'MISC').toUpperCase();\n            let found = categories[catName];\n            if (!found) {\n                const color = hashCode(catName) % 360;\n                let sat = '30%';\n                if (catName.toLowerCase().startsWith('obsolet')) {\n                    sat = '0%'; // Gray\n                }\n                found = {\n                    name: catName,\n                    hidden: false,\n                    color: color + ', ' + sat,\n                    buttons: []\n                };\n                categories[catName] = found;\n            }\n            found.buttons.push({\n                hidden: false,\n                category: catName,\n                widgetindex: btn.id,\n                widgetkey: btn.key,\n                widgetname: btn.name,\n                widgettitle: btn.name + \" \" + catName,\n                iconname: \"fa fas fa-eye\",\n                disabled: !btn.isUsableInScope(),\n                selectable: btn.insertquery != null,\n                isfilter: isFilter,\n                filterset: isFilter && autoFilters.includes(btn.key)\n            });\n        });\n        const categoriesList = Object.values(categories);\n        categoriesList.sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            }\n            if (a.name > b.name) {\n                return 1;\n            }\n            return 0;\n        });\n        categoriesList.forEach(cat => {\n            cat.buttons.sort();\n            cat.hidden = cat.buttons.filter(btn => !btn.hidden).length == 0;\n        });\n\n         // Update the list of recently used widgets\n        const recentList = this.storage.getRecentUsed().filter((/** @type {any} **/ recent) => {\n                // In select mode must filter widgets that do support it\n                const key = recent.key;\n                const widget = snptDict[key];\n                if (!widget) {\n                    return false;\n                }\n                const selectable = widget.insertquery !== undefined;\n                const isSelection = this.isSelectMode();\n                return key.length > 0 && (!isSelection || (isSelection && selectable));\n             })\n             .map((/** @type {any} **/ recent) => {\n                const key = recent.key;\n                 const snpt = snptDict[key];\n                 if (snpt) {\n                     return {\n                         key: key,\n                         name: snpt.name\n                     };\n                 } else {\n                     return {\n                         key: key,\n                         name: \"\"\n                     };\n                 }\n             });\n\n        return {\n            rid: genID(),\n            selectMode: this.isSelectMode(),\n            elementid: this.editor.id,\n            categories: categoriesList, ...(data ?? {}),\n            recent: recentList\n        };\n    }\n\n    /**\n     * Handle a click within the Modal.\n     *\n     * @param {Event} event The click event\n     */\n    async handlePickModalClick(event) {\n        /** @type {any} */\n        const target = event.target;\n        if (!target) {\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const buttonWrapper = target.closest('[data-key]');\n        /** @type {Widget | null} */\n        let widget = null;\n        if (buttonWrapper) {\n            const selectedButton = buttonWrapper?.dataset?.key;\n            if (selectedButton) {\n                widget = this.editorOptions.widgetDict[selectedButton];\n            }\n        }\n        if (!widget) {\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const button = target.closest('button.btn');\n        // Check if it is a toggle button to autoset a filter\n        if (button?.dataset?.auto) {\n            const isSet = button.dataset.auto !== \"true\";\n            button.dataset.auto = isSet + '';\n            toggleClass(button, 'btn-primary', 'btn-outline-primary');\n            const key = widget.key;\n            // Persist option\n            const autoFilters = new Set(this.storage.getFromLocal('startup.filters', '').split(''));\n            if (isSet) {\n                autoFilters.add(key);\n            } else {\n                autoFilters.delete(key);\n            }\n            this.storage.setToLocal('startup.filters', [...autoFilters].join(\",\"), true);\n            return;\n        }\n        /** @type {HTMLElement | undefined} */\n        const aRecent = target.closest('a[data-key]');\n        // If it is a recently used widget, recover the used parameters\n        /** @type {Record<string, any> | undefined} */\n        let ctx;\n        if (aRecent) {\n            ctx = this.storage.getRecentUsed().filter(e => e.key === widget.key)[0]?.p;\n        }\n        // Must open a configuration dialogue for the current widget\n        let confirmMsg = null;\n        if (!widget.isUsableInScope()) {\n            confirmMsg = \"Aquest widget no és adequat per a la pàgina actual. Segur que voleu continuar?\";\n        }\n\n        const forceInsert = aRecent !== null || button.dataset.insert === 'true';\n        if (confirmMsg) {\n            this.editor.windowManager.confirm(confirmMsg,\n            /** @param {*} state */\n            (state) => {\n                if (state) {\n                    this.handlePickModalAction(widget, forceInsert, ctx);\n                }\n            });\n        } else {\n            this.handlePickModalAction(widget, forceInsert, ctx);\n        }\n    }\n\n    /**\n     * @param {import('../options').Widget} widget\n     * @param {boolean} [forceInsert]\n     * @param {Record<string, *>} [ctx]\n     */\n    handlePickModalAction(widget, forceInsert, ctx) {\n        this.modal?.destroy();\n        this.modal = undefined;\n        const paramsController = this.widgetParamsFactory(widget);\n        // Keep reference to the calling parentCtrl\n        paramsController.parentCtrl = this;\n        // Decide whether to show the form or directly doInsert\n        if (forceInsert || (widget.parameters ?? []).length === 0 && !widget.instructions) {\n            // Do insert directly\n            paramsController.insertWidget(ctx ?? {});\n        } else {\n            paramsController.handleAction();\n        }\n    }\n}\n\nconst widgetPickerCtrlInstances = new Map();\n/**\n * @param {import('../plugin').TinyMCE} editor\n * @returns {WidgetPickerCtrl}\n */\nexport function getWidgetPickCtrl(editor) {\n    let instance = widgetPickerCtrlInstances.get(editor);\n    if (!instance) {\n        instance = new WidgetPickerCtrl(editor,\n            getEditorOptions(editor), getWidgetParamsFactory(editor),\n            getModalSrv(), getTemplateSrv(), getUserStorage(editor));\n        widgetPickerCtrlInstances.set(editor, instance);\n    }\n    return instance;\n}\n"],"names":["editor","instance","widgetPickerCtrlInstances","get","WidgetPickerCtrl","set","toggleVisible","el","visible","classList","remove","add","constructor","editorOptions","widgetParamsFactory","modalSrv","templateSrv","userStorage","storage","show","modal","isSelectMode","this","selection","getContent","trim","length","selectMode","onSearchKeyup","numshown","searchText","body","find","value","setToSession","allbtns","document","querySelectorAll","allcatgs","forEach","dataset","selectable","el2","querySelector","title","count","console","log","header","removeClass","addClass","getFromSession","data","getPickTemplateContext","create","destroy","scrollspy","ex","error","previewPanel","widgetTable","widgetDict","mouseEnterDebounced","async","key","evt","target","widget","isFilter","html","_preview","generatePreview","css","oMouseOut","clear","widgetSearchElem","val","debouncedKeyup","on","rid","trigger","event","handlePickModalClick","setTimeout","_this$modal2","focus","snptDict","allButtons","Object","values","autoFilters","getFromLocal","split","map","f","categories","btn","catName","category","toUpperCase","found","color","sat","toLowerCase","startsWith","name","hidden","buttons","push","widgetindex","id","widgetkey","widgetname","widgettitle","iconname","disabled","isUsableInScope","insertquery","isfilter","filterset","includes","categoriesList","sort","a","b","cat","filter","recentList","getRecentUsed","recent","undefined","isSelection","snpt","elementid","buttonWrapper","closest","selectedButton","_buttonWrapper$datase","button","_button$dataset","auto","isSet","Set","delete","setToLocal","join","aRecent","ctx","e","_this$storage$getRece","p","confirmMsg","forceInsert","insert","windowManager","confirm","state","handlePickModalAction","paramsController","parentCtrl","parameters","instructions","insertWidget","handleAction","Map"],"mappings":"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"}