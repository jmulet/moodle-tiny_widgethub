{"version":3,"file":"dom_service.min.js","sources":["../../src/service/dom_service.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport jquery from \"jquery\";\n\nexport class DomSrv {\n    /**\n     * @param {JQueryStatic} jQuery\n     */\n    constructor(jQuery) {\n        /** @type {JQueryStatic} */\n        this.jQuery = jQuery;\n    }\n\n    /**\n     * When creating a clone of an element must update all its id's\n     * @param {JQuery<HTMLElement>} $e - The element to be treated\n     * @param {JQuery<HTMLElement>} $target - The root element being cloned\n     * @param {JQuery<HTMLElement>} $root - The root element providing the context\n     * @param {Record<string, string>} idMap - A dictionary to store assigned id's\n     */\n    treatElementIds($e, $target, $root, idMap) {\n        const oldId = $e.prop('id');\n        if (oldId) {\n            let newId = idMap[oldId];\n            if (!newId) {\n                const ext = Math.random().toString(32).substring(2, 5);\n                newId = oldId + ext;\n                idMap[oldId] = newId;\n            }\n            $e.prop('id', newId);\n        }\n        // Does $e contain references to another elements in the $root which are not in $target?\n        ['data-target', 'data-bs-target', 'href'].forEach((dataX) => {\n            const attr = $e.attr(dataX);\n            if (attr?.startsWith(\"#\")) {\n                $e.removeClass('active show');\n                const rootRef = $root.find(attr);\n                const targetRef = $target.find(attr);\n                if (rootRef.length) {\n                    if (targetRef.length) {\n                        // Simply rename property\n                        const oldId = attr.substring(1);\n                        let newId = idMap[oldId];\n                        if (!newId) {\n                            const ext = Math.random().toString(32).substring(2, 5);\n                            newId = oldId + ext;\n                            idMap[oldId] = newId;\n                        }\n                        $e.attr(dataX, \"#\" + newId);\n                    } else {\n                        // (TODO: Deep cloning here?) Must clone the reference as well\n                        const newId = 'd' + Math.random().toString(32).substring(2);\n                        const clonedRef = rootRef.clone().prop(\"id\", newId);\n                        $e.prop(dataX, \"#\" + newId);\n                        clonedRef.insertAfter(rootRef).removeClass(\"active show\");\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * @param {JQuery<HTMLElement>} $e - the element that must be cloned\n     * @param {JQuery<HTMLElement>} $root - the root element (widget root)\n     * @param {Record<string,string>} idMap - old vs new id map\n     * @returns {JQuery<HTMLElement>} The cloned element with new id's\n     */\n    smartClone($e, $root, idMap) {\n        const clone = $e.clone();\n        this.treatElementIds(clone, $e, $root, idMap);\n        clone.find('*').each((_, e) => {\n            this.treatElementIds(this.jQuery(e), $e, $root, idMap);\n        });\n        return clone;\n    }\n\n    /**\n     * @param {JQuery<HTMLElement>} $e - Look in $e and all its descendants if references any other element in $root\n     * @param {JQuery<HTMLElement>} $root\n     * @returns {JQuery<HTMLElement>[]} - A list of referenced elements in $e\n     */\n    findReferences($e, $root) {\n        const searchFor = '[data-target^=\"#\"], [data-bs-target^=\"#\"], [href^=\"#\"]';\n        /** @type {HTMLElement[]} */\n        const found = [];\n        if ($e.is(searchFor)) {\n            let attr = $e.attr('data-target') ?? $e.attr('data-bs-target') ?? $e.attr('href');\n            if (attr) {\n                found.push(...$root.find(attr).toArray());\n            }\n        }\n        if (!found.length) {\n            // Look in descendants\n            const $descendants = $e.find(searchFor);\n            if ($descendants.length) {\n                let attr = $descendants.attr('data-target') ?? $descendants.attr('data-bs-target') ?? $descendants.attr('href');\n                if (attr) {\n                    found.push(...$root.find(attr).toArray());\n                }\n            }\n        }\n        return found.map(e => this.jQuery(e));\n    }\n\n    /**\n     * @param {HTMLElement} elem\n     * @param {string | string[]} [selectors]\n     * @returns {boolean}\n     */\n    matchesSelectors(elem, selectors) {\n        if (!selectors) {\n            return false;\n        }\n        /** @type {string} **/\n        let selector;\n        /** @type {string[]} **/\n        let extraQuery = [];\n        if (Array.isArray(selectors)) {\n            selector = selectors[0];\n            if (selectors.length > 1) {\n                extraQuery = selectors.slice(1);\n            }\n        } else {\n            selector = selectors;\n        }\n        /* @type {boolean} */\n        let match = elem.matches(selector);\n        if (match) {\n            extraQuery.forEach(e => {\n                match = match && elem.querySelector(e) !== null;\n            });\n        }\n        return match;\n    }\n\n    /**\n     * Defines the type PathResult\n     * @typedef {Object} PathResult\n     * @property {JQuery<HTMLElement>} selectedElement - The DOM element from which the search starts.\n     * @property {JQuery<HTMLElement>} [elem] - Indicates the element corresponding to the selector of the widget found\n     * @property {JQuery<HTMLElement>} [targetElement] - Indicates the element corresponding the intermediate selector\n     * @property {import('../options').Widget=} widget - The current widget definition associated with the elem\n     */\n\n    /**\n     * Walks the DOM tree up from the selectedElement and tries\n     * to find the first element that matches the selector of\n     * some widget.\n     * @param {import('../options').Widget[]} widgetList - The list of widgets\n     * @param {HTMLElement} selectedElement - The starting element in the search\n     * @returns {PathResult} The element and widget found in the search.\n     */\n    findWidgetOnEventPath(widgetList, selectedElement) {\n        /** @type {PathResult} */\n        const res = {\n            selectedElement: this.jQuery(selectedElement)\n        };\n        /** @type {HTMLElement | null} */\n        let elem = selectedElement;\n        const n = widgetList.length;\n        while (elem !== null && elem !== undefined && elem !== null &&\n            elem.getAttribute(\"name\") !== \"BODY\" && res.widget === undefined) {\n            let i = 0;\n            while (i < n && res.widget === undefined) {\n                if (this.matchesSelectors(elem, widgetList[i].selectors)) {\n                    res.widget = widgetList[i];\n                    res.elem = this.jQuery(elem);\n                }\n                i++;\n            }\n            elem = elem.parentElement;\n        }\n        // If no widget is found and selectedElement has a parent OL or IMG,\n        // force detection with a fake widget.\n        if (!res.widget) {\n            const parent = res.selectedElement.closest('ol,img');\n            let tag = res.selectedElement.prop('tagName');\n            const isTag = tag === 'OL' || tag === 'IMG';\n            if (isTag || parent[0]) {\n                if (!isTag) {\n                    tag = parent.prop('tagName');\n                }\n                /** @ts-ignore */\n                res.widget = {key: `!${tag}`, prop: () => ''};\n                res.targetElement = isTag ? res.selectedElement : parent;\n            }\n        }\n        return res;\n    }\n}\n\n/** @type {DomSrv | undefined} */\nlet instanceSrv;\n/**\n * @returns {DomSrv}\n */\nexport function getDomSrv() {\n    if (!instanceSrv) {\n        // @ts-ignore\n        instanceSrv = new DomSrv(jquery);\n    }\n    return instanceSrv;\n}\n"],"names":["instanceSrv","DomSrv","jquery","constructor","jQuery","treatElementIds","$e","$target","$root","idMap","oldId","prop","newId","Math","random","toString","substring","forEach","dataX","attr","startsWith","removeClass","rootRef","find","targetRef","length","clonedRef","clone","insertAfter","smartClone","each","_","e","this","findReferences","searchFor","found","is","push","toArray","$descendants","map","matchesSelectors","elem","selectors","selector","extraQuery","Array","isArray","slice","match","matches","querySelector","findWidgetOnEventPath","widgetList","selectedElement","res","n","getAttribute","undefined","widget","i","parentElement","parent","closest","tag","isTag","key","targetElement"],"mappings":"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"}