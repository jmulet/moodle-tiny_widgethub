{"version":3,"file":"dom_service.min.js","sources":["../../src/service/dom_service.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2025 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nexport class DomSrv {\n    /**\n     * When creating a clone of an element must update all its id's\n     * @param {Element} el - The element to be treated\n     * @param {Element} target - The root element being cloned\n     * @param {Element} root - The root element providing the context\n     * @param {Record<string, string>} idMap - A dictionary to store assigned id's\n     */\n    treatElementIds(el, target, root, idMap) {\n        const oldId = el.id;\n        if (oldId) {\n            let newId = idMap[oldId];\n            if (!newId) {\n                const ext = Math.random().toString(32).substring(2, 5);\n                newId = oldId + ext;\n                idMap[oldId] = newId;\n            }\n            el.id = newId;\n        }\n        // Does el contain references to another elements in the root which are not in target?\n        ['data-target', 'data-bs-target', 'href'].forEach((dataX) => {\n            const attr = el.getAttribute(dataX);\n            if (attr?.startsWith(\"#\") && attr.length > 1) {\n                el.classList.remove('active', 'show');\n                const rootRef = root.querySelector(attr);\n                const targetRef = target.querySelector(attr);\n                if (rootRef) {\n                    if (targetRef) {\n                        // Simply rename property\n                        const oldId = attr.substring(1);\n                        let newId = idMap[oldId];\n                        if (!newId) {\n                            const ext = Math.random().toString(32).substring(2, 5);\n                            newId = oldId + ext;\n                            idMap[oldId] = newId;\n                        }\n                        el.setAttribute(dataX, \"#\" + newId);\n                    } else {\n                       // Generar un ID único\n                        const newId = 'd' + Math.random().toString(32).substring(2);\n\n                        // Clonar el elemento (deep clone si quieres incluir hijos)\n                        /** @type {any} */\n                        const clonedRef = rootRef.cloneNode(true);\n\n                        // Asignar el nuevo ID\n                        clonedRef.id = newId;\n\n                        // Actualizar el atributo/data en el elemento original\n                        el.setAttribute(dataX, \"#\" + newId);\n\n                        // Compatibilidad con Bootstrap: actualizar el otro atributo\n                        if (dataX === 'data-bs-target') {\n                            el.setAttribute('data-target', \"#\" + newId);\n                        } else if (dataX === 'data-target') {\n                            el.setAttribute('data-bs-target', \"#\" + newId);\n                        }\n\n                        // Insertar el clon después del original\n                        rootRef.parentNode?.insertBefore(clonedRef, rootRef.nextSibling);\n\n                        // Quitar clases \"active\" y \"show\"\n                        clonedRef.classList.remove('active', 'show');\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * @param {Element} el - the element that must be cloned\n     * @param {Element} root - the root element (widget root)\n     * @param {Record<string,string>} idMap - old vs new id map\n     * @returns {Element} The cloned element with new id's\n     */\n    smartClone(el, root, idMap) {\n        /** @type {*} */\n        const clone = el.cloneNode(true);\n        this.treatElementIds(clone, el, root, idMap);\n        clone.querySelectorAll('*').forEach((/** @type {HTMLElement} */ e) => {\n            this.treatElementIds(e, el, root, idMap);\n        });\n        return clone;\n    }\n\n    /**\n     * @param {Element} el - Look in el and all its descendants if references any other element in root\n     * @param {Element} root\n     * @returns {Element[]} - A list of referenced elements in el\n     */\n    findReferences(el, root) {\n        const searchFor = '[data-target^=\"#\"], [data-bs-target^=\"#\"], [href^=\"#\"]';\n        /** @type {Element[]} */\n        const found = [];\n        if (el.matches(searchFor)) {\n            const attr = el.getAttribute('data-target')\n                ?? el.getAttribute('data-bs-target')\n                ?? el.getAttribute('href');\n\n            if (attr && attr !== '#') {\n                // QuerySelectorAll returns a NodeList; convert to array with spread.\n                found.push(...root.querySelectorAll(attr));\n            }\n        }\n\n        if (!found.length) {\n            // Look in descendants\n            el.querySelectorAll(searchFor).forEach(desc => {\n                const attr = desc.getAttribute('data-target')\n                        ?? desc.getAttribute('data-bs-target')\n                        ?? desc.getAttribute('href');\n\n                if (attr && attr !== '#') {\n                    found.push(...root.querySelectorAll(attr));\n                }\n            });\n        }\n        return found;\n    }\n\n    /**\n     * @param {HTMLElement} elem\n     * @param {string | string[]} [selectors]\n     * @returns {boolean}\n     */\n    matchesSelectors(elem, selectors) {\n        if (!selectors) {\n            return false;\n        }\n        /** @type {string} **/\n        let selector;\n        /** @type {string[]} **/\n        let extraQuery = [];\n        if (Array.isArray(selectors)) {\n            selector = selectors[0];\n            if (selectors.length > 1) {\n                extraQuery = selectors.slice(1);\n            }\n        } else {\n            selector = selectors;\n        }\n        /* @type {boolean} */\n        let match = elem.matches(selector);\n        if (match) {\n            extraQuery.forEach(e => {\n                match = match && elem.querySelector(e) !== null;\n            });\n        }\n        return match;\n    }\n\n    /**\n     * Defines the type PathResult\n     * @typedef {Object} PathResult\n     * @property {Element} selectedElement - The DOM element from which the search starts.\n     * @property {Element} [elem] - Indicates the element corresponding to the selector of the widget found\n     * @property {Element | null} [targetElement] - Indicates the element corresponding the intermediate selector\n     * @property {import('../options').Widget=} widget - The current widget definition associated with the elem\n     */\n\n    /**\n     * Walks the DOM tree up from the selectedElement and tries\n     * to find the first element that matches the selector of\n     * some widget.\n     * @param {import('../options').Widget[]} widgetList - The list of widgets\n     * @param {HTMLElement} selectedElement - The starting element in the search\n     * @returns {PathResult} The element and widget found in the search.\n     */\n    findWidgetOnEventPath(widgetList, selectedElement) {\n        /** @type {PathResult} */\n        const res = {\n            selectedElement\n        };\n        /** @type {HTMLElement | null} */\n        let elem = selectedElement;\n        const n = widgetList.length;\n        while (elem !== null && elem !== undefined && elem !== null &&\n            elem.getAttribute(\"name\") !== \"BODY\" && res.widget === undefined) {\n            let i = 0;\n            while (i < n && res.widget === undefined) {\n                if (this.matchesSelectors(elem, widgetList[i].selectors)) {\n                    res.widget = widgetList[i];\n                    res.elem = elem;\n                }\n                i++;\n            }\n            elem = elem.parentElement;\n        }\n        // If no widget is found and selectedElement has a parent OL or IMG,\n        // force detection with a fake widget.\n        if (!res.widget) {\n            const parent = res.selectedElement.closest('ol,img');\n            /** @type {string | undefined} */\n            let tag = res.selectedElement.tagName;\n            const isTag = tag === 'OL' || tag === 'IMG';\n            if (isTag || parent) {\n                if (!isTag) {\n                    tag = parent?.tagName;\n                }\n                /** @ts-ignore */\n                res.widget = {key: `!${tag}`, prop: () => ''};\n                res.targetElement = isTag ? res.selectedElement : parent;\n            }\n        }\n        return res;\n    }\n}\n\n/** @type {DomSrv | undefined} */\nlet instanceSrv;\n\n/**\n * @returns {DomSrv}\n */\nexport function getDomSrv() {\n    if (!instanceSrv) {\n        instanceSrv = new DomSrv();\n    }\n    return instanceSrv;\n}\n"],"names":["instanceSrv","DomSrv","treatElementIds","el","target","root","idMap","oldId","id","newId","Math","random","toString","substring","forEach","dataX","attr","getAttribute","startsWith","length","classList","remove","rootRef","querySelector","targetRef","setAttribute","clonedRef","cloneNode","parentNode","insertBefore","nextSibling","smartClone","clone","querySelectorAll","e","findReferences","searchFor","found","matches","push","desc","matchesSelectors","elem","selectors","selector","extraQuery","Array","isArray","slice","match","findWidgetOnEventPath","widgetList","selectedElement","res","n","undefined","widget","i","this","parentElement","parent","closest","tag","tagName","isTag","key","prop","targetElement"],"mappings":"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"}