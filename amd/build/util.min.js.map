{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/* eslint-disable no-console */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-new-func */\n/* eslint-disable dot-notation */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {get_strings as getStrings} from 'core/str';\nimport jQuery from 'jquery';\n\n\n/**\n * @typedef {object} Shared\n * @property {string} currentScope\n * @property {boolean} activatePopup\n * @property {object} globalConfig\n * @const\n */\nlet activatePopup = true;\nexport const Shared = {\n    // In which type of activity the editor is being used\n    currentScope: document.querySelector('body')?.id,\n    // Whether to activate the contextual popup or not\n    activatePopup: activatePopup,\n    // Hold other global configuration\n    globalConfig: {}\n};\n\n/**\n * @returns {string} a randomID\n */\nexport function genID() {\n    return 'g' + Math.random().toString(32).substring(2);\n}\n\n/**\n * @param {Object.<string, any>} ctx\n * @param {string} expr\n * @param {boolean=} keepFns - Keep or not the funcions in the ctx\n * @returns {any} The evaluated expression within the context ctx\n */\nexport function evalInContext(ctx, expr, keepFns) {\n    const listArgs = [];\n    const listVals = [];\n\n    if (ctx) {\n        Object.keys(ctx).forEach((key) => {\n            // Remove functions from ctx\n            if (keepFns || typeof ctx[key] !== \"function\") {\n                listArgs.push(key);\n                listVals.push(ctx[key]);\n            }\n        });\n    }\n    listArgs.push('expr');\n    listArgs.push('return eval(expr)');\n    listVals.push(expr);\n    const evaluator = new Function(...listArgs);\n    return evaluator(...listVals);\n}\n\n/**\n * @typedef {Object} ParamOption\n * @property {string} l\n * @property {string} v\n */\n/**\n * @typedef {Object} Param\n * @property {string=} partial\n * @property {string} name\n * @property {string} title\n * @property {'textfield' | 'numeric' | 'checkbox' | 'select' | 'textarea' | 'image' | 'color'} [type]\n * @property {(ParamOption | string)[]} [options]\n * @property {any} value\n * @property {string=} tip\n * @property {string=} tooltip\n * @property {number=} min\n * @property {number=} max\n * @property {string=} transform\n * @property {string | {get: string, set: string} } [bind]\n * @property {string=} when\n * @property {boolean} [hidden]\n * @property {boolean} [editable]\n */\n/**\n * @typedef {Object} Action\n * @property {string} predicate\n * @property {string} actions\n */\n/**\n * @typedef {Object} Widget\n * @property {number} id\n * @property {string} key\n * @property {string} category\n * @property {string=} scope - Regex for idenfying allowed body ids\n * @property {string} name\n * @property {string=} instructions\n * @property {'mustache' | 'ejs'} [engine]\n * @property {string} template\n * @property {Param[]=} parameters\n * @property {Object.<string, Object<string, string>>} [I18n]\n * @property {string | string[]} [selectors]\n * @property {string=} insertquery\n * @property {string=} unwrap\n * @property {string=} for\n * @property {string} version\n * @property {string} author\n * @property {boolean=} hidden\n * @property {Action[]} [contextmenu]\n */\n/**\n * @class\n * @classdesc Wrapper for Widget definition\n */\nexport class WidgetWrapper {\n    #widget;\n    #instructionsParsed = false;\n\n    /**\n     * @param {Widget} widget\n     * @param {Object.<string, any>=} partials\n     */\n    constructor(widget, partials) {\n        partials = partials ?? {};\n        this.#widget = widget;\n        const parameters = widget.parameters;\n        if (!parameters) {\n            return;\n        }\n        // Do some fixes on parameters\n        parameters.forEach((param, i) => {\n            // Case of a partial\n            if (param.partial) {\n                if (!partials[param.partial]) {\n                    console.error(\"Cannot find partial for \", param.partial, partials);\n                    return;\n                }\n                parameters[i] = partials[param.partial];\n            }\n            if (!param.type) {\n                if (param.options) {\n                    param.type = 'select';\n                } else if (typeof param.value === \"boolean\") {\n                    // Infer type from value\n                    param.type = 'checkbox';\n                } else if (typeof param.value === \"number\") {\n                    param.type = 'numeric';\n                } else if (typeof param.value === \"string\") {\n                    param.type = param.options ? 'select' : 'textfield';\n                }\n            }\n            if (!param.value) {\n                switch (param.type) {\n                    case ('checkbox'):\n                        param.value = false; break;\n                    case ('numeric'):\n                        param.value = 0; break;\n                    case ('select'):\n                        param.value = param.options?.[0];\n                        if (typeof (param.value) === 'object') {\n                            param.value = param.value.v;\n                        }\n                        break;\n                    case ('color'):\n                        param.value = '#ffffff'; break;\n                    default:\n                        param.value = '';\n                }\n            }\n        });\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        return this.#widget.name;\n    }\n    /**\n     * @returns {string}\n     */\n    get key() {\n        return this.#widget.key;\n    }\n    /**\n     * @returns {Record<string, Record<string, string>>}\n     */\n    get I18n() {\n        return this.#widget.I18n || {};\n    }\n    /**\n     * @returns {string}\n     */\n    get template() {\n        return this.#widget.template;\n    }\n    /**\n     * @returns {string}\n     */\n    get category() {\n        return this.#widget.category ?? \"MISC\";\n    }\n    /**\n     * @returns {string=}\n     */\n    get insertquery() {\n        return this.#widget.insertquery;\n    }\n    /**\n     * @returns {string | string[] =}\n     */\n    get selectors() {\n        return this.#widget.selectors;\n    }\n    /**\n     * @returns {string=}\n     */\n    get unwrap() {\n        return this.#widget.unwrap;\n    }\n    /**\n     * @returns {string}\n     */\n    get version() {\n        return this.#widget.version || \"1.0.0\";\n    }\n    /**\n     * @returns {string}\n     */\n    get instructions() {\n        if (this.#widget.instructions && !this.#instructionsParsed) {\n            this.#widget.instructions = decodeURIComponent(this.#widget.instructions);\n            this.#instructionsParsed = true;\n        }\n        return this.#widget.instructions ?? '';\n    }\n    /**\n     * @returns {Param[]}\n     */\n    get parameters() {\n        return this.#widget.parameters ?? [];\n    }\n    /**\n     * @returns {Object.<string, any>}\n     */\n    get defaults() {\n        /** @type {Object.<string, any> } */\n        const obj = {};\n        this.parameters.forEach((param) => {\n            obj[param.name] = param.value;\n        });\n        return obj;\n    }\n    /**\n     * @param {number} userId\n     * @returns {boolean}\n     */\n    isFor(userId) {\n        // These are administrators\n        if (this.#widget.hidden === true) {\n            return false;\n        }\n        let grantStr = (this.#widget.for || '').trim();\n        if (grantStr === '' || grantStr === '*' || userId <= 2) {\n            return true;\n        }\n        let allowMode = true;\n        if (grantStr.startsWith('-')) {\n            allowMode = false;\n        }\n        grantStr = grantStr.replace(/[+\\- ]/g, '');\n        const grantList = grantStr.split(\",\");\n        const isAllowed = (allowMode && grantList.indexOf(userId + \"\") >= 0) || (!allowMode && grantList.indexOf(userId + \"\") < 0);\n        return isAllowed;\n    }\n    /**\n     * @param {string=} scope\n     * @returns {boolean}\n     */\n    isUsableInScope(scope) {\n        scope = scope ?? Shared.currentScope ?? '';\n        const widgetScopes = this.#widget.scope;\n        if (!scope || !widgetScopes || widgetScopes === \"*\") {\n            return true;\n        }\n        const regex = new RegExp(widgetScopes);\n        return regex.exec(scope) != null;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFilter() {\n        return this.category?.toLowerCase() === \"filtres\";\n    }\n    /**\n     * @returns {boolean}\n     */\n    hasBindings() {\n        return this.parameters.filter(param => param.bind !== undefined).length > 0;\n    }\n    /**\n     * Recovers the property value named name of the original definition\n     * @param {string} name\n     * @returns {*}\n     */\n    prop(name) {\n        // @ts-ignore\n        return this.#widget[name];\n    }\n}\n\n/**\n * @param {string} s - string to the hashed\n * @returns {number}\n */\nexport function hashCode(s) {\n    s = s || \"\";\n    let h = 0;\n    const l = s.length;\n    let i = 0;\n    if (l > 0) {\n        while (i < l) {\n            h = (h << 6) + ((s.charCodeAt(i) - 65) | 0);\n            i++;\n        }\n    }\n    return Math.abs(h);\n}\n\n/**\n * @param {string} str1\n * @param {string} needle\n * @returns {boolean} Whether str1 contains needle or not\n */\nexport function searchComp(str1, needle) {\n    str1 = (str1 || '').trim().toLowerCase();\n    needle = (needle || '').trim().toLowerCase();\n    str1 = str1.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    needle = needle.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    return str1.indexOf(needle) >= 0;\n}\n\n/** Default transformers */\nconst Transformers = {\n    // @ts-ignore\n    \"toUpperCase\": function(txt) {\n        return (txt + \"\").toUpperCase();\n    },\n    // @ts-ignore\n    \"toLowerCase\": function(txt) {\n        return (txt + \"\").toLowerCase();\n    },\n    // @ts-ignore\n    \"trim\": function(txt) {\n        return (txt + \"\").trim();\n    },\n    // @ts-ignore\n    \"ytId\": function(txt) {\n        // Finds the youtubeId in a text\n        const rx = /^.*(?:(?:youtu\\.be\\/|v\\/|vi\\/|u\\/\\w\\/|embed\\/|shorts\\/)|(?:(?:watch)?\\?v(?:i)?=|&v(?:i)?=))([^#&?]*).*/;\n        const r = (txt || '').match(rx);\n        if (r?.length) {\n            return r[1];\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"vimeoId\": function(txt) {\n        const regExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?(\\d+)/;\n        const match = (txt || \"\").match(regExp);\n        if (match?.[5]) {\n            return match[5];\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"serveGDrive\": function(txt) {\n        // Expecting https://drive.google.com/file/d/1DDUzcFrOlzWb3CBdFPJ1NCNXClvPbm5B/preview\n        const res = (txt + \"\").match(/https:\\/\\/drive.google.com\\/file\\/d\\/([a-zA-Z0-9_]+)\\//);\n        if (res?.length) {\n            const driveId = res[1];\n            return \"https://docs.google.com/uc?export=open&id=\" + driveId;\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"removeHTML\": function(txt) {\n        return (txt || '').replace(/<[^>]*>?/gm, '');\n    },\n    // @ts-ignore\n    \"escapeHTML\": function(txt) {\n        return (txt || '').replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#039;\");\n    },\n    // @ts-ignore\n    \"encodeHTML\": function(txt) {\n        // @ts-ignore\n        return this.encodeURIComponent(txt || \"\");\n    },\n    // @ts-ignore\n    \"escapeQuotes\": function(txt) {\n        return (txt || '').replace(/\"/gm, \"'\");\n    }\n};\n\n\nclass Builder {\n    transSeq;\n    // @ts-ignore\n    constructor(transformStr) {\n        const parts = transformStr.split('|');\n        this.transSeq = [];\n        for (let j = 0, lenj = parts.length; j < lenj; j++) {\n            const prts = parts[j].trim();\n            // @ts-ignore\n            const transfunc = Transformers[prts];\n            if (transfunc != null) {\n                this.transSeq.push(transfunc);\n            } else {\n                console.error(\"Cannot find transformer named \" + prts);\n            }\n        }\n    }\n\n    // @ts-ignore\n    reduce(text) {\n        for (let j = 0, lenj = this.transSeq.length; j < lenj; j++) {\n            const transfunc = this.transSeq[j];\n            text = transfunc(text);\n        }\n        return text;\n    }\n}\n\n/**\n * @param {string} transformStr\n * @returns {Builder} call reduce(text) function\n */\nexport function stream(transformStr) {\n    return new Builder(transformStr);\n}\n\n/**\n * @param {string} name\n * @returns {string} Replaces $ apperences by _ to make the name compatible by data attributes\n */\nexport function cleanParameterName(name) {\n    return name.replace(/\\$/g, '_');\n}\n\n/**\n * Creates a filter funcion from filterCode\n * @param {string} filterCode\n * @returns {Function?}\n */\nexport function createFilterFunction(filterCode) {\n    filterCode = filterCode.replace('<!--<widgetcode>', '').replace('</widgetcode>-->', '');\n    let userWidgetFilter = null;\n    try {\n        userWidgetFilter = new Function('text', 'tiny', 'opts', filterCode);\n    } catch (ex) {\n        userWidgetFilter = null;\n        console.error(ex);\n    }\n    return userWidgetFilter;\n}\n/**\n * @param {import('./plugin').TinyMCE} editor\n * @param {string} widgetTemplate\n * @param {boolean} silent\n * @param {object?} mergevars\n * @returns {Promise<boolean>} - True if the filter can be compiled\n */\nexport async function applyWidgetFilter(editor, widgetTemplate, silent, mergevars) {\n    const translations = await getStrings([\n        {key: 'filterres', component: 'tiny_widgethub'},\n        {key: 'nochanges', component: 'tiny_widgethub'}\n    ]);\n    // Es tracta d'un filtre, no d'un widget i s'ha de tractar de forma diferent\n    const userWidgetFilter = createFilterFunction(widgetTemplate);\n\n    if (!userWidgetFilter) {\n        editor.notificationManager.open({\n            text: translations[0] + \": Invalid filter\",\n            type: 'danger',\n            timeout: 4000\n        });\n        return false;\n    }\n    // @ts-ignore\n    const handleFilterResult = function(res) {\n        const out = res[0];\n        let msg = res[1];\n        if (out != null) {\n            if (typeof out === \"string\") {\n                editor.setContent(out);\n                editor.notificationManager.open({\n                    text: translations[0] + \": \" + msg,\n                    type: 'success',\n                    timeout: 5000\n                });\n            } else if (out === true) {\n                editor.notificationManager.open({\n                    text: translations[0] + \": \" + msg,\n                    type: 'success',\n                    timeout: 5000\n                });\n            } else if (out === false && !silent) {\n                editor.notificationManager.open({\n                    text: translations[1],\n                    type: 'info',\n                    timeout: 4000\n                });\n            }\n        } else if (!silent) {\n            editor.notificationManager.open({\n                text: translations[1],\n                type: 'info',\n                timeout: 4000\n            });\n        }\n    };\n\n    const initialHTML = editor.getContent();\n    const filteredResult = userWidgetFilter(initialHTML, editor.dom.window, mergevars);\n    // Hi ha la possibilitat que el filtre retorni una promesa o un array\n    const isPromise = filteredResult != null && typeof (filteredResult) === 'object' && ('then' in filteredResult);\n    if (isPromise) {\n        filteredResult.then(handleFilterResult);\n    } else {\n        handleFilterResult(filteredResult || [null, translations[1]]);\n    }\n    return true;\n}\n\n/**\n * Safe conversion of a string to integer by handling errors and NaN values\n * In this case, the def number passed is returned\n * @param {string | undefined | null | number} str\n * @param {number} def - default value\n * @returns {number}\n */\nexport function convertInt(str, def) {\n    if (str && typeof str === 'number') {\n        return Math.floor(str);\n    }\n    if (!str || !(str + \"\").trim() || !RegExp(/^\\s*[+-]?\\d+(\\.\\d*)?\\s*$/).exec(str + \"\")) {\n        return def;\n    }\n    try {\n        const val = parseInt(str + \"\");\n        if (!isNaN(val)) {\n            return val;\n        }\n    } catch (ex) {\n        // Pass\n    }\n    return def;\n}\n\n/**\n * Finds the parameter with a given name within the list of objects\n * @param {string} varname\n * @param {Param[]} listVars\n * @returns {Param | null}\n */\nexport function findVariableByName(varname, listVars) {\n    if (!listVars) {\n        return null;\n    }\n    let found = null;\n    const len = listVars.length;\n    let k = 0;\n    while (k < len && !found) {\n        if (listVars[k].name === varname) {\n            found = listVars[k];\n        }\n        k++;\n    }\n    return found;\n}\n\n/**\n * Safely joins two parts of an url\n * @param {string} a\n * @param {string=} b\n * @returns {string}\n */\nexport function pathJoin(a, b) {\n    a = (a || \"\").trim();\n    b = (b || \"\").trim();\n    if (!a.endsWith('/')) {\n        a = a + '/';\n    }\n    if (b.startsWith('/')) {\n        b = b.substring(1);\n    }\n    return a + b;\n}\n\n/**\n * Adds the baseurl if the passed url does not start with http or https\n * @param {string} base\n * @param {string=} url\n * @returns {string}\n */\nexport function addBaseToUrl(base, url) {\n    url = (url || \"\").trim();\n    if (url.toLowerCase().startsWith(\"http\")) {\n        return url;\n    }\n    // Afegir la base\n    const out = pathJoin(base, url);\n    return out;\n}\n/**\n * Creates a script tag and adds it to the head section. It handles loading and error cases\n * @param {string} url\n * @param {string} [id]\n * @param {() => void} [onSuccess]\n * @param {() => void} [onError]\n */\nexport function addScript(url, id, onSuccess, onError) {\n    if (id && document.head.querySelector('script#' + id) != null) {\n        // Check if already in head\n        return;\n    }\n    const newScript = document.createElement('script');\n    newScript.type = \"text/javascript\";\n    newScript.src = url;\n    if (id) {\n        newScript.setAttribute(\"id\", id);\n    }\n    newScript.onload = () => {\n        if (onSuccess) {\n            onSuccess();\n        }\n    };\n    newScript.onerror = function() {\n        console.error(\"Error loading \", url);\n        if (onError) {\n            onError();\n        }\n    };\n    document.head.append(newScript);\n}\n\n// @ts-ignore\nconst performCasting = function(value, type) {\n    switch (type) {\n        case (\"boolean\"):\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\n                value = true;\n            } else {\n                value = false;\n            }\n            break;\n        case (\"number\"):\n            try {\n                value = parseInt(value);\n            } catch (ex) {\n                console.error(\"Error parsing number\", ex);\n            }\n            break;\n        case (\"string\"):\n            value = value + \"\";\n            break;\n    }\n    return value;\n};\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n */\nconst xor = function(a, b) {\n    return !a !== !b;\n};\n\n/**\n *\n * @param {JQuery<HTMLElement>} $e\n * @returns\n */\nconst bindingFactory = function($e) {\n    /** @this {Record<string, Function>} */\n    const methods = {\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasClass\": (className, query, neg) => {\n            /** @type {JQuery<HTMLElement>} */\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                // @ts-ignore\n                getValue: () => {\n                    const res = xor(neg, elem.hasClass(className));\n                    return Boolean(res);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem.addClass(className);\n                    } else {\n                        elem.removeClass(className);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasClass: (className, query) => {\n            return methods['hasClass'](className, query, true);\n        },\n        /**\n         * @param {string} classExpr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"classRegex\": (classExpr, query, castTo) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                getValue: () => {\n                    let ret = \"\";\n                    // @ts-ignore\n                    const cl = elem.attr('class')?.split(/\\s+/) ?? [];\n                    cl.forEach(c => {\n                        const match = c.match(classExpr);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            ret = match[1];\n                        }\n                    });\n                    return performCasting(ret, castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    const cl = elem.attr('class')?.split(/\\s+/) ?? [];\n                    // @ts-ignore\n                    cl.forEach(c => {\n                        if (c.match(classExpr)) {\n                            elem.removeClass(c);\n                        }\n                    });\n                    elem.addClass(classExpr.replace(\"(.*)\", val + \"\"));\n                }\n            };\n        },\n        /**\n         * @param {string} attrName\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"attr\": (attrName, query, castTo) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                getValue: () => {\n                    return performCasting(elem.attr(attrName), castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    return elem.attr(attrName, val + \"\");\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasAttr\": (attr, query, neg) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue: () => {\n                    let found = elem.attr(attrName) != null;\n                    if (attrValue) {\n                        found = found && elem.attr(attrName) === attrValue;\n                    }\n                    return xor(neg, found);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem.attr(attrName, attrValue || '');\n                    } else {\n                        elem.removeAttr(attrName);\n                    }\n                }\n            };\n        },\n         /**\n          * @param {string} attr\n          * @param {string=} query\n          * @returns {Binding}\n          */\n        \"notHasAttr\": (attr, query) => {\n            return methods['hasAttr'](attr, query, true);\n        },\n        /**\n         * @param {string} attr - Regex of attr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"attrRegex\": function(attr, query, castTo) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    let found = elem.attr(attrName) != null;\n                    if (found) {\n                        const match = elem.attr(attrName)?.match(attrValue);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            return performCasting(match[1], castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                // @ts-ignore\n                setValue(val) {\n                    elem.attr(attrName, attrValue.replace(\"(.*)\", val + \"\"));\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasStyle\": function(sty, query, neg) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = sty.split(\":\");\n            let styName = parts[0].trim();\n            /** @type {string | undefined} */\n            let styValue;\n            if (parts.length > 1) {\n                styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    const st = elem.prop('style');\n                    const pValue = st.getPropertyValue(styName);\n                    const has = styValue === undefined ? pValue !== '' : pValue === styValue;\n                    return xor(has, neg);\n                },\n                // @ts-ignore\n                setValue(bool) {\n                    if (xor(bool, neg)) {\n                        elem.css(styName, styValue ?? '');\n                    } else {\n                        const st = elem.prop('style');\n                        st.removeProperty(styName);\n                    }\n                }\n            };\n        },\n         /**\n          * @param {string} sty\n          * @param {string=} query\n          * @returns {Binding}\n          */\n        \"notHasStyle\": (sty, query) => {\n            return methods['hasStyle'](sty, query, true);\n        },\n        /**\n         * @param {string} attr - styName:styValue where styValue is a regex with (.*)\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"styleRegex\": function(attr, query, castTo) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\":\");\n            const styName = parts[0].trim();\n            let styValue = '';\n            if (parts.length > 1) {\n                styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    const st = elem.prop('style');\n                    const has = st.getPropertyValue(styName) != null;\n                    if (has) {\n                        if (styValue) {\n                            const match = st.getPropertyValue(styName).match(styValue);\n                            if (match?.[1] && (typeof match[1]) === \"string\") {\n                                return performCasting(match[1], castTo);\n                            }\n                        } else {\n                            const match = st.getPropertyValue(styName);\n                            return performCasting(match, castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                // @ts-ignore\n                setValue(val) {\n                    if (styValue) {\n                        elem.css(styName, styValue.replace(\"(.*)\", val + \"\"));\n                    } else {\n                        // @ts-ignore\n                        elem.css(styName, val);\n                    }\n                }\n            };\n        }\n    };\n    return methods;\n};\n\n/**\n * @typedef {Object} Binding\n * @property {() => unknown} getValue\n * @property {(value: unknown) => void} setValue\n */\n/**\n * @param {string | {get: string, set: string}} definition\n * @param {JQuery<HTMLElement>} elem  - The root of widget\n * @param {string=} castTo  - The type that must be returned\n * @returns {Binding | null}\n */\nexport const createBinding = (definition, elem, castTo) => {\n    /** @type {Binding | null} */\n    let bindFn = null;\n    if (typeof (definition) === 'string') {\n        return evalInContext({...bindingFactory(elem)}, definition, true);\n    } else {\n        // The user provides the get and set functions\n        bindFn = {\n            getValue: () => {\n                let v = evalInContext({elem}, `(${definition.get})(elem)`);\n                if (castTo) {\n                    v = performCasting(v, castTo);\n                }\n                return v;\n            },\n            setValue: (v) => evalInContext({elem, v}, `(${definition.set})(elem, v)`)\n        };\n    }\n    return bindFn;\n};\n\n/**\n * Capitalizes the first letter of a string\n * @param {string | undefined | null} s\n * @returns {string}\n */\nexport const capitalize = s => (s && s[0].toUpperCase() + s.slice(1)) || \"\";\n\n/**\n * When creating a clone of an element must update all its id's\n * @param {JQuery<HTMLElement>} $e - The element to be treated\n * @param {JQuery<HTMLElement>} $target - The root element being cloned\n * @param {JQuery<HTMLElement>} $root - The root element providing the context\n * @param {Record<string, string>} idMap - A dictionary to store assigned id's\n */\nconst treatElementIds = function($e, $target, $root, idMap) {\n    const oldId = $e.prop('id');\n    if (oldId) {\n        let newId = idMap[oldId];\n        if (!newId) {\n            const ext = Math.random().toString(32).substring(2, 5);\n            newId = oldId + ext;\n            idMap[oldId] = newId;\n        }\n        $e.prop('id', newId);\n    }\n    // Does $e contain references to another elements in the $root which are not in $target?\n    ['data-target', 'data-bs-target', 'href'].forEach((dataX) => {\n        const attr = $e.attr(dataX);\n        if (attr?.startsWith(\"#\")) {\n            $e.removeClass('active show');\n            const rootRef = $root.find(attr);\n            const targetRef = $target.find(attr);\n            if (rootRef.length) {\n                if (targetRef.length) {\n                    // Simply rename property\n                    const oldId = attr.substring(1);\n                    let newId = idMap[oldId];\n                    if (!newId) {\n                        const ext = Math.random().toString(32).substring(2, 5);\n                        newId = oldId + ext;\n                        idMap[oldId] = newId;\n                    }\n                    $e.attr(dataX, \"#\" + newId);\n                } else {\n                    // (TODO: Deep cloning here?) Must clone the reference as well\n                    const newId = 'd' + Math.random().toString(32).substring(2);\n                    const clonedRef = rootRef.clone().prop(\"id\", newId);\n                    $e.prop(dataX, \"#\" + newId);\n                    clonedRef.insertAfter(rootRef).removeClass(\"active show\");\n                }\n            }\n        }\n    });\n};\n\n/**\n * @param {JQuery<HTMLElement>} $e - the element that must be cloned\n * @param {JQuery<HTMLElement>} $root - the root element (widget root)\n * @param {Record<string,string>} idMap - old vs new id map\n * @returns {JQuery<HTMLElement>} The cloned element with new id's\n */\nexport const smartClone = ($e, $root, idMap) => {\n    const clone = $e.clone();\n    treatElementIds(clone, $e, $root, idMap);\n    clone.find('*').each((_, e) => {\n        treatElementIds(jQuery(e), $e, $root, idMap);\n    });\n    return clone;\n};\n\n/**\n * @param {JQuery<HTMLElement>} $e - Look in $e and all its descendants if references any other element in $root\n * @param {JQuery<HTMLElement>} $root\n * @returns {JQuery<HTMLElement>[]} - A list of referenced elements in $e\n */\nexport function findReferences($e, $root) {\n    const searchFor = '[data-target^=\"#\"], [data-bs-target^=\"#\"], [href^=\"#\"]';\n    /** @type {HTMLElement[]} */\n    const found = [];\n    if ($e.is(searchFor)) {\n        let attr = $e.attr('data-target') ?? $e.attr('data-bs-target') ?? $e.attr('href');\n        if (attr) {\n            found.push(...$root.find(attr).toArray());\n        }\n    }\n    if (!found.length) {\n        // Look in descendants\n        const $descendants = $e.find(searchFor);\n        if ($descendants.length) {\n            let attr = $descendants.attr('data-target') ?? $descendants.attr('data-bs-target') ?? $descendants.attr('href');\n            if (attr) {\n                found.push(...$root.find(attr).toArray());\n            }\n        }\n    }\n    return found.map(e => jQuery(e));\n}\n\n/**\n * @param {string} color\n * @returns {string} - The color in hex format\n */\nexport function toHexColor(color) {\n    if (!color) {\n        return \"#000000\";\n    } else if (color.trim().startsWith(\"#\")) {\n        return color.trim();\n    }\n    // Assume rgb\n    const a = color.replace(/[^\\d,]/g, \"\").split(\",\");\n    return \"#\" + ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + +a[2]).toString(16).slice(1);\n  }"],"names":["base","url","trim","toLowerCase","startsWith","pathJoin","id","onSuccess","onError","document","head","querySelector","newScript","createElement","type","src","setAttribute","onload","onerror","console","error","append","editor","widgetTemplate","silent","mergevars","translations","key","component","userWidgetFilter","createFilterFunction","notificationManager","open","text","timeout","handleFilterResult","res","out","msg","setContent","initialHTML","getContent","filteredResult","dom","window","then","name","replace","str","def","Math","floor","RegExp","exec","val","parseInt","isNaN","ex","$e","$root","searchFor","found","is","attr","push","find","toArray","length","$descendants","map","e","varname","listVars","len","k","random","toString","substring","s","h","l","i","charCodeAt","abs","str1","needle","indexOf","transformStr","Builder","color","a","split","slice","Shared","currentScope","_document$querySelect","activatePopup","globalConfig","evalInContext","ctx","expr","keepFns","listArgs","listVals","Object","keys","forEach","Function","evaluator","constructor","widget","partials","parameters","param","partial","options","value","_param$options","v","this","I18n","template","category","insertquery","selectors","unwrap","version","instructions","instructionsParsed","decodeURIComponent","defaults","obj","isFor","userId","hidden","grantStr","for","allowMode","grantList","isUsableInScope","scope","widgetScopes","isFilter","hasBindings","filter","undefined","bind","prop","Transformers","txt","toUpperCase","r","match","encodeURIComponent","transSeq","parts","j","lenj","prts","transfunc","reduce","filterCode","b","endsWith","performCasting","xor","bindingFactory","methods","className","query","neg","elem","getValue","hasClass","Boolean","setValue","bool","addClass","removeClass","notHasClass","classExpr","castTo","ret","c","attrName","attrValue","removeAttr","_elem$attr3","sty","styValue","styName","pValue","getPropertyValue","css","removeProperty","st","definition","bindFn","get","set","treatElementIds","$target","idMap","oldId","newId","dataX","rootRef","targetRef","clonedRef","clone","insertAfter","each","_"],"mappings":"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"}