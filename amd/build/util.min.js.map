{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/* eslint-disable no-console */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-new-func */\n/* eslint-disable dot-notation */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * @returns {string} a randomID\n */\nexport function genID() {\n    return 'g' + Math.random().toString(32).substring(2);\n}\n\n/**\n * @param {Object.<string, any>} ctx\n * @param {string} expr\n * @param {boolean=} keepFns - Keep or not the funcions in the ctx\n * @returns {any} The evaluated expression within the context ctx\n */\nexport function evalInContext(ctx, expr, keepFns) {\n    const listArgs = [];\n    const listVals = [];\n\n    if (ctx) {\n        Object.keys(ctx).forEach((key) => {\n            // Remove functions from ctx\n            if (keepFns || typeof ctx[key] !== \"function\") {\n                listArgs.push(key);\n                listVals.push(ctx[key]);\n            }\n        });\n    }\n    listArgs.push('expr');\n    listArgs.push('return eval(expr)');\n    listVals.push(expr);\n    const evaluator = new Function(...listArgs);\n    return evaluator(...listVals);\n}\n\n/**\n * @param {string} s - string to the hashed\n * @returns {number}\n */\nexport function hashCode(s) {\n    s = s || \"\";\n    let h = 0;\n    const l = s.length;\n    let i = 0;\n    if (l > 0) {\n        while (i < l) {\n            h = (h << 6) + ((s.charCodeAt(i) - 65) | 0);\n            i++;\n        }\n    }\n    return Math.abs(h);\n}\n\n/**\n * @param {string} str1\n * @param {string} needle\n * @returns {boolean} Whether str1 contains needle or not\n */\nexport function searchComp(str1, needle) {\n    str1 = (str1 || '').trim().toLowerCase();\n    needle = (needle || '').trim().toLowerCase();\n    str1 = str1.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    needle = needle.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    return str1.indexOf(needle) >= 0;\n}\n\n/** Default transformers */\nconst Transformers = {\n    // @ts-ignore\n    \"toUpperCase\": function (txt) {\n        return (txt + \"\").toUpperCase();\n    },\n    // @ts-ignore\n    \"toLowerCase\": function (txt) {\n        return (txt + \"\").toLowerCase();\n    },\n    // @ts-ignore\n    \"trim\": function (txt) {\n        return (txt + \"\").trim();\n    },\n    // @ts-ignore\n    \"ytId\": function (txt) {\n        // Finds the youtubeId in a text\n        const rx = /^.*(?:(?:youtu\\.be\\/|v\\/|vi\\/|u\\/\\w\\/|embed\\/|shorts\\/)|(?:(?:watch)?\\?v(?:i)?=|&v(?:i)?=))([^#&?]*).*/;\n        const r = (txt || '').match(rx);\n        if (r?.length) {\n            return r[1];\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"vimeoId\": function (txt) {\n        const regExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?(\\d+)/;\n        const match = (txt || \"\").match(regExp);\n        if (match?.[5]) {\n            return match[5];\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"serveGDrive\": function (txt) {\n        // Expecting https://drive.google.com/file/d/1DDUzcFrOlzWb3CBdFPJ1NCNXClvPbm5B/preview\n        const res = (txt + \"\").match(/https:\\/\\/drive.google.com\\/file\\/d\\/([a-zA-Z0-9_]+)\\//);\n        if (res?.length) {\n            const driveId = res[1];\n            return \"https://docs.google.com/uc?export=open&id=\" + driveId;\n        }\n        return txt;\n    },\n    // @ts-ignore\n    \"removeHTML\": function (txt) {\n        return (txt || '').replace(/<[^>]*>?/gm, '');\n    },\n    // @ts-ignore\n    \"escapeHTML\": function (txt) {\n        return (txt || '').replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#039;\");\n    },\n    // @ts-ignore\n    \"encodeHTML\": function (txt) {\n        // @ts-ignore\n        return this.encodeURIComponent(txt || \"\");\n    },\n    // @ts-ignore\n    \"escapeQuotes\": function (txt) {\n        return (txt || '').replace(/\"/gm, \"'\");\n    }\n};\n\n\nclass Builder {\n    transSeq;\n    // @ts-ignore\n    constructor(transformStr) {\n        const parts = transformStr.split('|');\n        this.transSeq = [];\n        for (let j = 0, lenj = parts.length; j < lenj; j++) {\n            const prts = parts[j].trim();\n            // @ts-ignore\n            const transfunc = Transformers[prts];\n            if (transfunc != null) {\n                this.transSeq.push(transfunc);\n            } else {\n                console.error(\"Cannot find transformer named \" + prts);\n            }\n        }\n    }\n\n    // @ts-ignore\n    reduce(text) {\n        for (let j = 0, lenj = this.transSeq.length; j < lenj; j++) {\n            const transfunc = this.transSeq[j];\n            text = transfunc(text);\n        }\n        return text;\n    }\n}\n\n/**\n * @param {string} transformStr\n * @returns {Builder} call reduce(text) function\n */\nexport function stream(transformStr) {\n    return new Builder(transformStr);\n}\n\n/**\n * @param {string} name\n * @returns {string} Replaces $ apperences by _ to make the name compatible by data attributes\n */\nexport function cleanParameterName(name) {\n    return name.replace(/\\$/g, '_');\n}\n\n/**\n * Creates a filter funcion from filterCode\n * @param {string} filterCode\n * @returns {Function?}\n */\nexport function createFilterFunction(filterCode) {\n    filterCode = filterCode.replace('<!--<widgetcode>', '').replace('</widgetcode>-->', '');\n    let userWidgetFilter = null;\n    try {\n        userWidgetFilter = new Function('text', 'tiny', 'opts', filterCode);\n    } catch (ex) {\n        userWidgetFilter = null;\n        console.error(ex);\n    }\n    return userWidgetFilter;\n}\n\n/**\n * @param {import('./plugin').TinyMCE} editor\n * @param {{get_strings: (keyComponent: any[]) => Promise<string[]>}} coreStr - dependency on core/str\n * @returns {*}\n */\nexport function applyWidgetFilterFactory(editor, coreStr) {\n    /**\n     * @param {string} widgetTemplate\n     * @param {boolean} silent\n     * @param {object?} mergevars\n     * @returns {Promise<boolean>} - True if the filter can be compiled\n     */\n    return async (widgetTemplate, silent, mergevars) => {\n        const translations = await coreStr.get_strings([\n            { key: 'filterres', component: 'tiny_widgethub' },\n            { key: 'nochanges', component: 'tiny_widgethub' }\n        ]);\n        // Es tracta d'un filtre, no d'un widget i s'ha de tractar de forma diferent\n        const userWidgetFilter = createFilterFunction(widgetTemplate);\n\n        if (!userWidgetFilter) {\n            editor.notificationManager.open({\n                text: translations[0] + \": Invalid filter\",\n                type: 'danger',\n                timeout: 4000\n            });\n            return false;\n        }\n        // @ts-ignore\n        const handleFilterResult = function (res) {\n            const out = res[0];\n            let msg = res[1];\n            if (out != null) {\n                if (typeof out === \"string\") {\n                    editor.setContent(out);\n                    editor.notificationManager.open({\n                        text: translations[0] + \": \" + msg,\n                        type: 'success',\n                        timeout: 5000\n                    });\n                } else if (out === true) {\n                    editor.notificationManager.open({\n                        text: translations[0] + \": \" + msg,\n                        type: 'success',\n                        timeout: 5000\n                    });\n                } else if (out === false && !silent) {\n                    editor.notificationManager.open({\n                        text: translations[1],\n                        type: 'info',\n                        timeout: 4000\n                    });\n                }\n            } else if (!silent) {\n                editor.notificationManager.open({\n                    text: translations[1],\n                    type: 'info',\n                    timeout: 4000\n                });\n            }\n        };\n\n        const initialHTML = editor.getContent();\n        const filteredResult = userWidgetFilter(initialHTML, editor.dom.window, mergevars);\n        // Hi ha la possibilitat que el filtre retorni una promesa o un array\n        const isPromise = filteredResult != null && typeof (filteredResult) === 'object' && ('then' in filteredResult);\n        if (isPromise) {\n            filteredResult.then(handleFilterResult);\n        } else {\n            handleFilterResult(filteredResult || [null, translations[1]]);\n        }\n        return true;\n    };\n}\n\n/**\n * Safe conversion of a string to integer by handling errors and NaN values\n * In this case, the def number passed is returned\n * @param {string | undefined | null | number} str\n * @param {number} def - default value\n * @returns {number}\n */\nexport function convertInt(str, def) {\n    if (str && typeof str === 'number') {\n        return Math.floor(str);\n    }\n    if (!str || !(str + \"\").trim() || !RegExp(/^\\s*[+-]?\\d+(\\.\\d*)?\\s*$/).exec(str + \"\")) {\n        return def;\n    }\n    try {\n        const val = parseInt(str + \"\");\n        if (!isNaN(val)) {\n            return val;\n        }\n    } catch (ex) {\n        // Pass\n    }\n    return def;\n}\n\n/**\n * Finds the parameter with a given name within the list of objects\n * @param {string} varname\n * @param {import('./options').Param[]} listVars\n * @returns {import('./options').Param | null}\n */\nexport function findVariableByName(varname, listVars) {\n    if (!listVars) {\n        return null;\n    }\n    let found = null;\n    const len = listVars.length;\n    let k = 0;\n    while (k < len && !found) {\n        if (listVars[k].name === varname) {\n            found = listVars[k];\n        }\n        k++;\n    }\n    return found;\n}\n\n/**\n * Safely joins two parts of an url\n * @param {string} a\n * @param {string=} b\n * @returns {string}\n */\nexport function pathJoin(a, b) {\n    a = (a || \"\").trim();\n    b = (b || \"\").trim();\n    if (!a.endsWith('/')) {\n        a = a + '/';\n    }\n    if (b.startsWith('/')) {\n        b = b.substring(1);\n    }\n    return a + b;\n}\n\n/**\n * Adds the baseurl if the passed url does not start with http or https\n * @param {string} base\n * @param {string=} url\n * @returns {string}\n */\nexport function addBaseToUrl(base, url) {\n    url = (url || \"\").trim();\n    if (url.toLowerCase().startsWith(\"http\")) {\n        return url;\n    }\n    // Afegir la base\n    const out = pathJoin(base, url);\n    return out;\n}\n/**\n * Creates a script tag and adds it to the head section. It handles loading and error cases\n * @param {string} url\n * @param {string} [id]\n * @param {() => void} [onSuccess]\n * @param {() => void} [onError]\n */\nexport function addScript(url, id, onSuccess, onError) {\n    if (id && document.head.querySelector('script#' + id) != null) {\n        // Check if already in head\n        return;\n    }\n    const newScript = document.createElement('script');\n    newScript.type = \"text/javascript\";\n    newScript.src = url;\n    if (id) {\n        newScript.setAttribute(\"id\", id);\n    }\n    newScript.onload = () => {\n        if (onSuccess) {\n            onSuccess();\n        }\n    };\n    newScript.onerror = function () {\n        console.error(\"Error loading \", url);\n        if (onError) {\n            onError();\n        }\n    };\n    document.head.append(newScript);\n}\n\n// @ts-ignore\nconst performCasting = function (value, type) {\n    switch (type) {\n        case (\"boolean\"):\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\n                value = true;\n            } else {\n                value = false;\n            }\n            break;\n        case (\"number\"):\n            try {\n                value = parseInt(value);\n            } catch (ex) {\n                console.error(\"Error parsing number\", ex);\n            }\n            break;\n        case (\"string\"):\n            value = value + \"\";\n            break;\n    }\n    return value;\n};\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n */\nconst xor = function (a, b) {\n    return !a !== !b;\n};\n\n/**\n *\n * @param {JQuery<HTMLElement>} $e\n * @returns\n */\nconst bindingFactory = function ($e) {\n    /** @this {Record<string, Function>} */\n    const methods = {\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasClass\": (className, query, neg) => {\n            /** @type {JQuery<HTMLElement>} */\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                // @ts-ignore\n                getValue: () => {\n                    const res = xor(neg, elem.hasClass(className));\n                    return Boolean(res);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem.addClass(className);\n                    } else {\n                        elem.removeClass(className);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasClass: (className, query) => {\n            return methods['hasClass'](className, query, true);\n        },\n        /**\n         * @param {string} classExpr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"classRegex\": (classExpr, query, castTo) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                getValue: () => {\n                    let ret = \"\";\n                    // @ts-ignore\n                    const cl = elem.attr('class')?.split(/\\s+/) ?? [];\n                    cl.forEach(c => {\n                        const match = c.match(classExpr);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            ret = match[1];\n                        }\n                    });\n                    return performCasting(ret, castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    const cl = elem.attr('class')?.split(/\\s+/) ?? [];\n                    // @ts-ignore\n                    cl.forEach(c => {\n                        if (c.match(classExpr)) {\n                            elem.removeClass(c);\n                        }\n                    });\n                    elem.addClass(classExpr.replace(\"(.*)\", val + \"\"));\n                }\n            };\n        },\n        /**\n         * @param {string} attrName\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"attr\": (attrName, query, castTo) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            return {\n                getValue: () => {\n                    return performCasting(elem.attr(attrName), castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    return elem.attr(attrName, val + \"\");\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasAttr\": (attr, query, neg) => {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue: () => {\n                    let found = elem.attr(attrName) != null;\n                    if (attrValue) {\n                        found = found && elem.attr(attrName) === attrValue;\n                    }\n                    return xor(neg, found);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem.attr(attrName, attrValue || '');\n                    } else {\n                        elem.removeAttr(attrName);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        \"notHasAttr\": (attr, query) => {\n            return methods['hasAttr'](attr, query, true);\n        },\n        /**\n         * @param {string} attr - Regex of attr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"attrRegex\": function (attr, query, castTo) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    let found = elem.attr(attrName) != null;\n                    if (found) {\n                        const match = elem.attr(attrName)?.match(attrValue);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            return performCasting(match[1], castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                // @ts-ignore\n                setValue(val) {\n                    elem.attr(attrName, attrValue.replace(\"(.*)\", val + \"\"));\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        \"hasStyle\": function (sty, query, neg) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = sty.split(\":\");\n            let styName = parts[0].trim();\n            /** @type {string | undefined} */\n            let styValue;\n            if (parts.length > 1) {\n                styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    const st = elem.prop('style');\n                    const pValue = st.getPropertyValue(styName);\n                    const has = styValue === undefined ? pValue !== '' : pValue === styValue;\n                    return xor(has, neg);\n                },\n                // @ts-ignore\n                setValue(bool) {\n                    if (xor(bool, neg)) {\n                        elem.css(styName, styValue ?? '');\n                    } else {\n                        const st = elem.prop('style');\n                        st.removeProperty(styName);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        \"notHasStyle\": (sty, query) => {\n            return methods['hasStyle'](sty, query, true);\n        },\n        /**\n         * @param {string} attr - styName:styValue where styValue is a regex with (.*)\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        \"styleRegex\": function (attr, query, castTo) {\n            let elem = $e;\n            if (query) {\n                elem = $e.find(query);\n            }\n            const parts = attr.split(\":\");\n            const styName = parts[0].trim();\n            let styValue = '';\n            if (parts.length > 1) {\n                styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n            return {\n                getValue() {\n                    const st = elem.prop('style');\n                    const has = st.getPropertyValue(styName) != null;\n                    if (has) {\n                        if (styValue) {\n                            const match = st.getPropertyValue(styName).match(styValue);\n                            if (match?.[1] && (typeof match[1]) === \"string\") {\n                                return performCasting(match[1], castTo);\n                            }\n                        } else {\n                            const match = st.getPropertyValue(styName);\n                            return performCasting(match, castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                // @ts-ignore\n                setValue(val) {\n                    if (styValue) {\n                        elem.css(styName, styValue.replace(\"(.*)\", val + \"\"));\n                    } else {\n                        // @ts-ignore\n                        elem.css(styName, val);\n                    }\n                }\n            };\n        }\n    };\n    return methods;\n};\n\n/**\n * @typedef {Object} Binding\n * @property {() => unknown} getValue\n * @property {(value: unknown) => void} setValue\n */\n/**\n * @param {string | {get: string, set: string}} definition\n * @param {JQuery<HTMLElement>} elem  - The root of widget\n * @param {string=} castTo  - The type that must be returned\n * @returns {Binding | null}\n */\nexport const createBinding = (definition, elem, castTo) => {\n    /** @type {Binding | null} */\n    let bindFn = null;\n    if (typeof (definition) === 'string') {\n        return evalInContext({ ...bindingFactory(elem) }, definition, true);\n    } else {\n        // The user provides the get and set functions\n        bindFn = {\n            getValue: () => {\n                let v = evalInContext({ elem }, `(${definition.get})(elem)`);\n                if (castTo) {\n                    v = performCasting(v, castTo);\n                }\n                return v;\n            },\n            setValue: (v) => evalInContext({ elem, v }, `(${definition.set})(elem, v)`)\n        };\n    }\n    return bindFn;\n};\n\n/**\n * Capitalizes the first letter of a string\n * @param {string | undefined | null} s\n * @returns {string}\n */\nexport const capitalize = s => (s && s[0].toUpperCase() + s.slice(1)) || \"\";\n\n/**\n * @param {string} color\n * @returns {string} - The color in hex format\n */\nexport function toHexColor(color) {\n    if (!color) {\n        return \"#000000\";\n    } else if (color.trim().startsWith(\"#\")) {\n        return color.trim();\n    }\n    // Assume rgb\n    const a = color.replace(/[^\\d,]/g, \"\").split(\",\");\n    return \"#\" + ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + +a[2]).toString(16).slice(1);\n}"],"names":["evalInContext","ctx","expr","keepFns","listArgs","listVals","Object","keys","forEach","key","push","Function","evaluator","base","url","trim","toLowerCase","startsWith","pathJoin","id","onSuccess","onError","document","head","querySelector","newScript","createElement","type","src","setAttribute","onload","onerror","console","error","append","editor","coreStr","async","widgetTemplate","silent","mergevars","translations","get_strings","component","userWidgetFilter","createFilterFunction","notificationManager","open","text","timeout","handleFilterResult","res","out","msg","setContent","filteredResult","getContent","dom","window","then","name","replace","str","def","Math","floor","RegExp","exec","val","parseInt","isNaN","ex","varname","listVars","found","len","length","k","random","toString","substring","s","h","l","i","charCodeAt","abs","str1","needle","indexOf","transformStr","Builder","color","a","split","slice","Transformers","txt","toUpperCase","r","match","this","encodeURIComponent","transSeq","constructor","parts","j","lenj","prts","transfunc","reduce","filterCode","b","endsWith","performCasting","value","xor","bindingFactory","$e","methods","className","query","neg","elem","find","getValue","hasClass","Boolean","setValue","bool","addClass","removeClass","notHasClass","classExpr","castTo","ret","attr","c","attrName","attrValue","removeAttr","_elem$attr3","sty","styValue","styName","pValue","prop","getPropertyValue","undefined","css","removeProperty","st","definition","bindFn","v","get","set"],"mappings":"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"}