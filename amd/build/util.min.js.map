{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/* eslint-disable no-console */\n/* eslint-disable max-len */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-new-func */\n/* eslint-disable dot-notation */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pmulet@iedib.net>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport Mustache from 'core/mustache';\n\nimport {get_strings as getStrings} from 'core/str';\n\n// Load on demand the template engines\nlet Ejs;\n/**\n * @returns {Promise<EJS>}\n */\nfunction getEJS() {\n    if (Ejs) {\n        return Promise.resolve(Ejs);\n    }\n    return new Promise((resolve, reject) => {\n        require(['tiny_widgethub/ejs-lazy'], (ejsModule) => {\n            Ejs = ejsModule;\n            resolve(Ejs);\n        }, reject);\n    });\n}\n\n/**\n * @typedef {object} Shared\n * @property {string} currentScope\n * @property {string} SNPT_MODE\n * @property {object} globalConfig\n * @const\n */\nlet activatePopup = true;\nexport const Shared = {\n    // In which type of activity the editor is being used\n    currentScope: document.querySelector('body')?.id,\n    // Whether to activate the contextual popup or not\n    activatePopup: activatePopup,\n    // Hold other global configuration\n    globalConfig: {}\n};\n\n/**\n * @returns {string} a randomID\n */\nexport function genID() {\n    return 'g' + Math.random().toString(32).substring(2);\n}\n\n/**\n * @param {object} ctx\n * @param {string} expr\n * @returns {any} The evaluated expression within the context ctx\n */\nexport function scopedEval(ctx, expr) {\n    const listArgs = [];\n    const listVals = [];\n    // Remove functions from ctx\n    if (ctx) {\n        Object.keys(ctx).forEach((key) => {\n            if (typeof ctx[key] !== \"function\") {\n                listArgs.push(key);\n                listVals.push(ctx[key]);\n            }\n        });\n    }\n    listArgs.push('expr');\n    listArgs.push('return eval(expr)');\n    listVals.push(expr);\n\n    const evaluator = new Function(...listArgs);\n    return evaluator(...listVals);\n}\n\nconst defineVar = function(text, ctx2) {\n    const pos = text.indexOf(\"=\");\n    const varname = text.substring(0, pos).trim();\n    const varvalue = scopedEval(ctx2, text.substring(pos + 1).trim());\n    ctx2[varname] = varvalue;\n    return varname;\n};\n\n/**\n * Extends Mustache templates with some helpers\n * @param {object} ctx\n * @param {object} translations\n */\nconst applyMustacheHelpers = function(ctx, translations) {\n    ctx[\"if\"] = () => function(text, render) {\n        const pos = text.indexOf(\"]\");\n        const condition = text.substring(0, pos).trim().substring(1);\n        const show = scopedEval(ctx, condition);\n        if (show) {\n            return render(text.substring(pos + 1).trim());\n        }\n        return \"\";\n    };\n    ctx[\"var\"] = () => function(text) {\n        defineVar(text, ctx);\n    };\n    ctx[\"eval\"] = () => function(text) {\n        return scopedEval(ctx, text) + \"\";\n    };\n    ctx[\"I18n\"] = () => function(text, render) {\n        const key = render(text).trim();\n        const dict = translations[key] || {};\n        return dict[ctx[\"LANG\"]] || dict[\"en\"] || dict[\"ca\"] || key;\n    };\n    ctx[\"each\"] = () => function(text) {\n        const pos = text.indexOf(\"]\");\n        const cond = text.substring(0, pos).trim().substring(1);\n        const components = cond.split(\",\");\n        const dim = components.length;\n        const maxValues = new Array(dim);\n        const loopVars = new Array(dim);\n        let total = 1;\n        const cc = 'i'.charCodeAt();\n        components.forEach((def, i) => {\n            const parts = def.split(\"=\");\n            if (parts.length === 1) {\n                parts.unshift(String.fromCharCode(cc + i));\n            }\n            const cname = parts[0].trim();\n            loopVars[i] = cname;\n            const dm = scopedEval(ctx, parts[1]);\n            total = total * dm;\n            maxValues[i] = dm;\n            ctx[cname] = 1;\n        });\n        let output = [];\n        for (let _ei = 0; _ei < total; _ei++) {\n            output.push(Mustache.render(text.substring(pos + 1), ctx));\n            let currentDim = dim - 1;\n            let incrUp;\n            do {\n                const oldValue = ctx[loopVars[currentDim]] - 1;\n                const newValue = (oldValue + 1) % maxValues[currentDim] + 1;\n                ctx[loopVars[currentDim]] = newValue;\n                incrUp = newValue < oldValue;\n                currentDim--;\n            } while (currentDim >= 0 && incrUp);\n        }\n        return output.join('');\n    };\n    ctx[\"for\"] = () => function(text) {\n        const pos = text.indexOf(\"]\");\n        const condition = text.substring(0, pos).trim().substring(1);\n        const parts = condition.split(\";\");\n        const loopvar = defineVar(parts[0], ctx);\n        let output = \"\";\n        let maxIter = 0; // Prevent infinite loop imposing a limit of 1000\n        while (scopedEval(ctx, parts[1]) && maxIter < 1000) {\n            output += Mustache.render(text.substring(pos + 1), ctx);\n            if (parts.length === 3 && parts[2].trim()) {\n                defineVar(loopvar + \"=\" + parts[2]);\n            } else {\n                ctx[loopvar] = ctx[loopvar] + 1;\n            }\n            maxIter++;\n        }\n        return output;\n    };\n};\n\n/**\n * @param {string} template\n * @param {object} context\n * @param {object | undefined} translations\n * @returns {string} The interpolated template given a context and translations map\n */\nexport function templateRendererMustache(template, context, translations) {\n    const ctx = {...context};\n    Object.keys(ctx).forEach(key => {\n        if (ctx[key] === \"$RND\") {\n            ctx[key] = genID();\n        }\n    });\n    applyMustacheHelpers(ctx, translations || {});\n    return Mustache.render(template, ctx);\n}\n\n\n/**\n * @param {string} template\n * @param {object} context\n * @param {object} translations\n * @returns {Promise<string>} The interpolated template given a context and translations map\n */\nasync function templateRendererEJS(template, context, translations) {\n    const ctx = {...context, I18n: {}};\n    Object.keys(ctx).forEach(key => {\n        if (ctx[key] === \"$RND\") {\n            ctx[key] = genID();\n        }\n    });\n    const lang = ctx[\"LANG\"];\n    for (let wordKey in translations) {\n        const dict = translations[wordKey];\n        ctx[\"I18n\"][wordKey] = dict[lang] || dict[\"en\"] || dict[\"es\"] || wordKey;\n    }\n    const _ejs = await getEJS();\n    return _ejs.render(template, ctx);\n}\n\n/**\n * @param {string} template\n * @param {object} context\n * @param {object} translations\n * @param {string} engine (ejs | mustache) optional\n * @returns {Promise<string>} The interpolated template given a context and translations map\n */\nexport function templateRenderer(template, context, translations, engine) {\n    if (!engine) {\n        engine = template.includes(\"<%\") ? \"ejs\" : \"mustache\";\n    }\n    if (engine === \"ejs\") {\n        return templateRendererEJS(template, context, translations);\n    }\n    // Default to Mustache\n    const tmpl = templateRendererMustache(template, context, translations);\n    return Promise.resolve(tmpl);\n}\n\n/**\n * Wrapper for Widget definition\n */\nexport class WidgetWrapper {\n    _snpt;\n    _instructionsParsed = false;\n\n    /**\n     * @param {WidgetWrapper} snpt\n     * @param {Object} partials\n     */\n    constructor(snpt, partials) {\n        // Do some fixes on parameters\n        snpt.parameters?.forEach((param, i) => {\n            // Case of a partial\n            if (param.partial) {\n                if (!partials[param.partial]) {\n                    console.error(\"Cannot find partial for \", param.partial, partials);\n                    return;\n                }\n                snpt.parameters[i] = partials[param.partial];\n            }\n            if (!param.type) {\n                if (typeof param.value === \"boolean\") {\n                    param.type = 'checkbox';\n                } else if (typeof param.value === \"number\") {\n                    param.type = 'numeric';\n                } else if (typeof param.value === \"string\") {\n                    param.type = param.options ? 'select' : 'textfield';\n                }\n            }\n        });\n        this._snpt = snpt;\n    }\n    /**\n     * @returns {string}\n     */\n    get name() {\n        return this._snpt.name;\n    }\n    /**\n     * @returns {string}\n     */\n    get key() {\n        return this._snpt.key;\n    }\n    get I18n() {\n        return this._snpt.I18n || {};\n    }\n    /**\n     * @returns {string}\n     */\n    get template() {\n        return this._snpt.template;\n    }\n    get category() {\n        return this._snpt.category || \"MISC\";\n    }\n    get insertquery() {\n        return this._snpt.insertquery;\n    }\n    get selectors() {\n        return this._snpt.selectors;\n    }\n    get unpack() {\n        return this._snpt.unpack;\n    }\n    get requires() {\n        if (Array.isArray(this._snpt.requires)) {\n            return this._snpt.requires[0];\n        }\n        return this._snpt.requires;\n    }\n    get stars() {\n        return this._snpt.stars;\n    }\n    get version() {\n        return this._snpt.version || \"1.0.0\";\n    }\n    /**\n     * @returns {string}\n     */\n    get instructions() {\n        if (!this._instructionsParsed) {\n            this._snpt.instructions = decodeURIComponent(this._snpt.instructions);\n            this._instructionsParsed = true;\n        }\n        return this._snpt.instructions;\n    }\n    /**\n     * @returns {object}\n     */\n    get parameters() {\n        return this._snpt.parameters || [];\n    }\n    /**\n     * @returns {object}\n     */\n    get defaults() {\n        const obj = {};\n        this.parameters.forEach((param) => {\n            obj[param.name] = param.value;\n        });\n        return obj;\n    }\n    /**\n     * @param {object} ctx\n     * @returns {Promise<string>} The rendered template\n     */\n    render(ctx) {\n        const defaultsCopy = {...this.defaults};\n        const toInterpolate = Object.assign(defaultsCopy, ctx || {});\n        // Decide which template engine to use\n        let engine = this._snpt.engine;\n        return templateRenderer(this.template ?? \"\", toInterpolate,\n            this._snpt.I18n ?? {}, engine);\n    }\n\n    /**\n     * @param {number} userId\n     * @returns {boolean}\n     */\n    isFor(userId) {\n        // These are administrators\n        if (this._snpt.hidden === true) {\n            return false;\n        }\n        let grantStr = (this._snpt.for || '').trim();\n        if (grantStr === '' || grantStr === '*' || userId <= 2) {\n            return true;\n        }\n        let allowMode = true;\n        if (grantStr.startsWith('-')) {\n            allowMode = false;\n        }\n        grantStr = grantStr.replace(/[+\\- ]/g, '');\n        const grantList = grantStr.split(\",\");\n        const isAllowed = (allowMode && grantList.indexOf(userId + \"\") >= 0) || (!allowMode && grantList.indexOf(userId + \"\") < 0);\n        return isAllowed;\n    }\n    /**\n     * @param {string} scope\n     * @returns {boolean}\n     */\n    isUsableInScope(scope) {\n        scope = scope || Shared.currentScope;\n        const widgetScopes = this._snpt.scope;\n        if (!scope || !widgetScopes || widgetScopes === \"*\") {\n            return true;\n        }\n        const regex = new RegExp(widgetScopes);\n        return regex.exec(scope) != null;\n    }\n    /**\n     * @returns {boolean}\n     */\n    isFilter() {\n        return this.category?.toLowerCase() === \"filtres\";\n    }\n    /**\n     * @returns {boolean}\n     */\n    hasBindings() {\n        return this.parameters.filter(param => param.bind !== undefined).length > 0;\n    }\n}\n\n/**\n * @param {string} s - string to the hashed\n * @returns {number}\n */\nexport function hashCode(s) {\n    s = s || \"\";\n    let h = 0;\n    const l = s.length;\n    let i = 0;\n    if (l > 0) {\n        while (i < l) {\n            h = (h << 6) + ((s.charCodeAt(i) - 65) | 0);\n            i++;\n        }\n    }\n    return Math.abs(h);\n}\n\n/**\n * Defines local and session storage classes for a given\n * context (user & course)\n */\nexport class UserStorage {\n    static _instances = {};\n    _userId = 0;\n    _courseId = 0;\n    _localStore;\n    _sessionStore;\n    STORE_KEY;\n    /**\n     * @param {number} userId\n     * @param {number} courseId\n     * @static\n     * @returns {UserStorage} - The instance\n     */\n    static getInstance(userId, courseId) {\n        const key = userId + \"_\" + courseId;\n        if (!UserStorage._instances[key]) {\n            UserStorage._instances[key] = new UserStorage(userId, courseId);\n        }\n        return UserStorage._instances[key];\n    }\n    // Private constructor\n    constructor(userId, courseId) {\n        this._userId = userId;\n        this._courseId = courseId;\n        this.STORE_KEY = \"iedib-widgets_\" + userId;\n        this._localStore = {valors: {}};\n        this._sessionStore = {searchtext: ''};\n        this.loadStore();\n    }\n    /**\n     * @returns {void}\n     */\n    loadStore() {\n        if (typeof window.localStorage !== 'undefined') {\n            const txt = window.localStorage.getItem(this.STORE_KEY);\n            if (txt) {\n                try {\n                    this._localStore = JSON.parse(txt);\n                } catch (ex) {\n                    console.error(ex);\n                }\n            }\n        }\n        // Added storage for this _course\n        if (!this._localStore[\"_\" + this._courseId]) {\n            this._localStore[\"_\" + this._courseId] = {};\n        }\n        if (typeof window.sessionStorage !== 'undefined') {\n            const txt2 = window.sessionStorage.getItem(this.STORE_KEY);\n            if (txt2) {\n                try {\n                    this._sessionStore = JSON.parse(txt2);\n                } catch (ex) {\n                    console.error(ex);\n                }\n            }\n        }\n    }\n    /**\n     * @template T\n     * @param {string} key\n     * @param {T} defaultValue\n     * @returns {T}\n     */\n    getFromLocal(key, defaultValue) {\n        if (!this._localStore) {\n            return defaultValue;\n        }\n        const MLSC = this._localStore[\"_\" + this._courseId]; // Almost everything goes here\n        const MLS = this._localStore; // Only configuration params\n        if (MLSC) {\n            return MLSC[key] || MLS[key] || defaultValue;\n        } else if (MLS) {\n            return MLS[key] || defaultValue;\n        }\n        return defaultValue;\n    }\n    /**\n     * @template T\n     * @param {string} key\n     * @param {T} defaultValue\n     * @returns {T}\n     */\n    getFromSession(key, defaultValue) {\n        return (this._sessionStore[key] != null ? this._sessionStore[key] : defaultValue);\n    }\n    /**\n     * @param {'local' | 'session' | undefined} type\n     */\n    saveStore(type) {\n        if (type === 'local' && typeof window.localStorage !== 'undefined') {\n            window.localStorage.setItem(this.STORE_KEY, JSON.stringify(this._localStore));\n        } else if (type === 'session' && typeof window.sessionStorage !== 'undefined') {\n            window.sessionStorage.setItem(this.STORE_KEY, JSON.stringify(this._sessionStore));\n        } else if (type == null) {\n            if (typeof window.localStorage !== 'undefined') {\n                window.localStorage.setItem(this.STORE_KEY, JSON.stringify(this._localStore));\n            }\n            if (typeof window.sessionStorage !== 'undefined') {\n                window.sessionStorage.setItem(this.STORE_KEY, JSON.stringify(this._sessionStore));\n            }\n        }\n    }\n    /**\n     * @template T\n     * @param {string} key\n     * @param {T} value\n     * @param {boolean} persist\n     * @returns {void}\n     */\n    setToLocal(key, value, persist) {\n        if (this._localStore == null) {\n            return;\n        }\n        const MLSC = this._localStore[\"_\" + this._courseId]; // Almost everything goes here\n        const MLS = this._localStore; // Only configuration params\n\n        if (typeof (theValueMap) === 'object') {\n            if (MLSC && key === 'saveall_data' || key === 'valors') {\n                MLSC[key] = MLSC[key] || {};\n            } else {\n                MLS[key] = MLS[key] || {};\n            }\n            const keys = Object.keys(value);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const theKey = keys[i];\n                const val = value[theKey];\n                if (MLSC && key === 'saveall_data' || key === 'valors') {\n                    MLSC[key][theKey] = val;\n                } else {\n                    MLS[key][theKey] = val;\n                }\n            }\n        } else {\n            MLS[key] = value;\n        }\n        if (persist) {\n            this.saveStore(\"local\");\n        }\n    }\n    /**\n     * @template T\n     * @param {string} key\n     * @param {T} value\n     * @param {boolean} persist\n     * @returns {void}\n     */\n    setToSession(key, value, persist) {\n        if (typeof (value) === 'object') {\n            this._sessionStore[key] = this._sessionStore[key] || {};\n            const keys = Object.keys(value);\n            for (let i = 0, len = keys.length; i < len; i++) {\n                const theKey = keys[i];\n                const val = value[theKey];\n                this._sessionStore[key][theKey] = val;\n            }\n        } else {\n            this._sessionStore[key] = value;\n        }\n        if (persist) {\n            this.saveStore(\"session\");\n        }\n    }\n\n}\n\n\n/**\n * @param {string} str1\n * @param {string} needle\n * @returns {boolean} Whether str1 contains needle or not\n */\nexport function searchComp(str1, needle) {\n    str1 = (str1 || '').trim().toLowerCase();\n    needle = (needle || '').trim().toLowerCase();\n    str1 = str1.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    needle = needle.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    return str1.indexOf(needle) >= 0;\n}\n\n/** Default transformers */\nconst Transformers = {\n    \"toUpperCase\": function(txt) {\n        return (txt + \"\").toUpperCase();\n    },\n    \"toLowerCase\": function(txt) {\n        return (txt + \"\").toLowerCase();\n    },\n    \"trim\": function(txt) {\n        return (txt + \"\").trim();\n    },\n    \"ytId\": function(txt) {\n        // Finds the youtubeId in a text\n        const rx = /^.*(?:(?:youtu\\.be\\/|v\\/|vi\\/|u\\/\\w\\/|embed\\/|shorts\\/)|(?:(?:watch)?\\?v(?:i)?=|&v(?:i)?=))([^#&?]*).*/;\n        const r = (txt || '').match(rx);\n        if (r?.length) {\n            return r[1];\n        }\n        return txt;\n    },\n    \"vimeoId\": function(txt) {\n        const regExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?(\\d+)/;\n        const match = (txt || \"\").match(regExp);\n        if (match?.[5]) {\n            return match[5];\n        }\n        return txt;\n    },\n    \"serveGDrive\": function(txt) {\n        // Expecting https://drive.google.com/file/d/1DDUzcFrOlzWb3CBdFPJ1NCNXClvPbm5B/preview\n        const res = (txt + \"\").match(/https:\\/\\/drive.google.com\\/file\\/d\\/([a-zA-Z0-9_]+)\\//);\n        if (res?.length) {\n            const driveId = res[1];\n            return \"https://docs.google.com/uc?export=open&id=\" + driveId;\n        }\n        return txt;\n    },\n    \"removeHTML\": function(txt) {\n        return (txt || '').replace(/<[^>]*>?/gm, '');\n    },\n    \"escapeHTML\": function(txt) {\n        return (txt || '').replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#039;\");\n    },\n    \"encodeHTML\": function(txt) {\n        return this.encodeURIComponent(txt || \"\");\n    },\n    \"escapeQuotes\": function(txt) {\n        return (txt || '').replace(/\"/gm, \"'\");\n    }\n};\n\n\nclass Builder {\n    transSeq;\n    constructor(transformStr) {\n        const parts = transformStr.split('|');\n        this.transSeq = [];\n        for (let j = 0, lenj = parts.length; j < lenj; j++) {\n            const prts = parts[j].trim();\n            const transfunc = Transformers[prts];\n            if (transfunc != null) {\n                this.transSeq.push(transfunc);\n            } else {\n                console.error(\"Cannot find transformer named \" + prts);\n            }\n        }\n    }\n\n    reduce(text) {\n        for (let j = 0, lenj = this.transSeq.length; j < lenj; j++) {\n            const transfunc = this.transSeq[j];\n            text = transfunc(text);\n        }\n        return text;\n    }\n}\n\n/**\n * @param {string} transformStr\n * @returns {Builder} call reduce(text) function\n */\nexport function stream(transformStr) {\n    return new Builder(transformStr);\n}\n\n/**\n * @param {string} name\n * @returns {string} Replaces $ apperences by _ to make the name compatible by data attributes\n */\nexport function cleanParameterName(name) {\n    return name.replace(/\\$/g, '_');\n}\n\n/**\n * Creates a filter funcion from filterCode\n * @param {string} filterCode\n * @returns {Function?}\n */\nexport function createFilterFunction(filterCode) {\n    filterCode = filterCode.replace('<!--<widgetcode>', '').replace('</widgetcode>-->', '');\n    let userWidgetFilter = null;\n    try {\n        userWidgetFilter = new Function('text', 'tiny', 'opts', filterCode);\n    } catch (ex) {\n        userWidgetFilter = null;\n        console.error(ex);\n    }\n    return userWidgetFilter;\n}\n/**\n * @param {tinyMCE} editor\n * @param {string} widgetTemplate\n * @param {boolean} silent\n * @param {object?} mergevars\n * @returns {boolean} - True if the filter can be compiled\n */\nexport async function applyWidgetFilter(editor, widgetTemplate, silent, mergevars) {\n    const translations = await getStrings([\n        {key: 'filterres', component: 'tiny_widgethub'},\n        {key: 'nochanges', component: 'tiny_widgethub'}\n    ]);\n    // Es tracta d'un filtre, no d'un widget i s'ha de tractar de forma diferent\n    const userWidgetFilter = createFilterFunction(widgetTemplate);\n\n    if (!userWidgetFilter) {\n        editor.notificationManager.open({\n            text: translations[0] + \": Invalid filter\",\n            type: 'danger',\n            timeout: 4000\n        });\n        return false;\n    }\n    const handleFilterResult = function(res) {\n        const out = res[0];\n        let msg = res[1];\n        if (out != null) {\n            if (typeof out === \"string\") {\n                editor.setContent(out);\n                editor.notificationManager.open({\n                    text: translations[0] + \": \" + msg,\n                    type: 'success',\n                    timeout: 5000\n                });\n            } else if (out === true) {\n                editor.notificationManager.open({\n                    text: translations[0] + \": \" + msg,\n                    type: 'success',\n                    timeout: 5000\n                });\n            } else if (out === false && !silent) {\n                editor.notificationManager.open({\n                    text: translations[1],\n                    type: 'info',\n                    timeout: 4000\n                });\n            }\n        } else if (!silent) {\n            editor.notificationManager.open({\n                text: translations[1],\n                type: 'info',\n                timeout: 4000\n            });\n        }\n    };\n\n    const initialHTML = editor.getContent();\n    const filteredResult = userWidgetFilter(initialHTML, editor.dom.window, mergevars);\n    // Hi ha la possibilitat que el filtre retorni una promesa o un array\n    const isPromise = filteredResult != null && typeof (filteredResult) === 'object' && ('then' in filteredResult);\n    if (isPromise) {\n        filteredResult.then(handleFilterResult);\n    } else {\n        handleFilterResult(filteredResult || [null, \"El filter no ha produït canvis\"]);\n    }\n    return true;\n}\n\n/**\n * Safe conversion of a string to integer by handling errors and NaN values\n * In this case, the def number passed is returned\n * @param {string | undefined | null | number} str\n * @param {number} def - default value\n * @returns {number}\n */\nexport function convertInt(str, def) {\n    if (str && typeof str === 'number') {\n        return Math.floor(str);\n    }\n    if (!str || !(str + \"\").trim() || !(str + \"\").match(/^\\s*[+-]?\\d+(\\.\\d*)?\\s*$/)) {\n        return def;\n    }\n    try {\n        const val = parseInt(str + \"\");\n        if (!isNaN(val)) {\n            return val;\n        }\n    } catch (ex) {\n        // Pass\n    }\n    return def;\n}\n\n/**\n * Finds the parameter with a given name within the list of objects\n * @param {string} varname\n * @param {WidgetParameter[]} listVars\n * @returns {WidgetParameter | null}\n */\nexport function findVariableByName(varname, listVars) {\n    if (!listVars) {\n        return null;\n    }\n    let found = null;\n    const len = listVars.length;\n    let k = 0;\n    while (k < len && !found) {\n        if (listVars[k].name === varname) {\n            found = listVars[k];\n        }\n        k++;\n    }\n    return found;\n}\n\n/**\n * Safely joins two parts of an url\n * @param {string} a\n * @param {string?} b\n * @returns {string}\n */\nexport function pathJoin(a, b) {\n    a = (a || \"\").trim();\n    b = (b || \"\").trim();\n    if (!a.endsWith('/')) {\n        a = a + '/';\n    }\n    if (b.startsWith('/')) {\n        b = b.substring(1);\n    }\n    return a + b;\n}\n\n/**\n * Adds the baseurl if the passed url does not start with http or https\n * @param {string} base\n * @param {string?} url\n * @returns {string}\n */\nexport function addBaseToUrl(base, url) {\n    url = (url || \"\").trim();\n    if (url.toLowerCase().startsWith(\"http\")) {\n        return url;\n    }\n    // Afegir la base\n    const out = pathJoin(base, url);\n    return out;\n}\n/**\n * Creates a script tag and adds it to the head section. It handles loading and error cases\n * @param {string} url\n * @param {string | undefined} id\n * @param {function() | undefined} onSuccess\n * @param {function() | undefined} onError\n */\nexport function addScript(url, id, onSuccess, onError) {\n    if (id && document.head.querySelector('script#' + id) != null) {\n        // Check if already in head\n        return;\n    }\n    const newScript = document.createElement('script');\n    newScript.type = \"text/javascript\";\n    newScript.src = url;\n    if (id) {\n        newScript.setAttribute(\"id\", id);\n    }\n    newScript.onload = () => {\n        console.info(\"Loaded \", url);\n        if (onSuccess) {\n            onSuccess();\n        }\n    };\n    newScript.onerror = function() {\n        console.error(\"Error loading \", url);\n        if (onError) {\n            onError();\n        }\n    };\n    document.head.append(newScript);\n}\n\nconst performCasting = function(value, type) {\n    switch (type) {\n        case (\"boolean\"):\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\n                value = true;\n            } else {\n                value = false;\n            }\n            break;\n        case (\"number\"):\n            try {\n                value = parseInt(value);\n            } catch (ex) {\n                console.error(\"Error parsing number\", ex);\n            }\n            break;\n        case (\"string\"):\n            value = value + \"\";\n            break;\n    }\n    return value;\n};\n\nconst BindingFactory = {\n    \"hasClass\": class {\n        constructor(elem, className, castTo, neg) {\n            this.elem = elem;\n            this.castTo = castTo;\n            this.neg = neg;\n            this.className = className;\n        }\n        getValue() {\n            // ^ XOR gate\n            const res = this.neg ^ this.elem.classList.contains(this.className);\n            return this.castTo === 'boolean' ? Boolean(res) : res;\n        }\n        setValue(bool) {\n            if (this.neg ^ bool) {\n                this.elem.classList.add(this.className);\n            } else {\n                this.elem.classList.remove(this.className);\n            }\n        }\n    },\n    \"classRegex\": class {\n        constructor(elem, classExpr, castTo) {\n            this.elem = elem;\n            this.castTo = castTo;\n            this.classExpr = classExpr;\n        }\n        getValue() {\n            let ret = \"\";\n            this.elem.classList.forEach(c => {\n                const match = c.match(this.classExpr);\n                if (match?.[1] && typeof (match[1]) === \"string\") {\n                    ret = match[1];\n                }\n            });\n            return performCasting(ret, this.castTo);\n        }\n        setValue(val) {\n            const cl = this.elem.classList;\n            cl.forEach(c => {\n                if (c.match(this.classExpr)) {\n                    cl.remove(c);\n                }\n            });\n            cl.add(this.classExpr.replace(\"(.*)\", val + \"\"));\n        }\n    },\n    \"attr\": class {\n        constructor(elem, attrName, castTo) {\n            this.elem = elem;\n            this.castTo = castTo;\n            this.attrName = attrName;\n        }\n        getValue() {\n            return performCasting(this.elem.getAttribute(this.attrName), this.castTo);\n        }\n        setValue(val) {\n            if (typeof val === \"boolean\") {\n                val = val ? 1 : 0;\n            }\n            return this.elem.setAttribute(this.attrName, val + \"\");\n        }\n    },\n    \"hasAttr\": class {\n        constructor(elem, attr, castTo, neg) {\n            this.elem = elem;\n            this.castTo = castTo;\n            this.neg = neg;\n            const parts = attr.split(\"=\");\n            this.attrName = parts[0].trim();\n            if (parts.length > 1) {\n                this.attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n        }\n        getValue() {\n            let found = this.elem.getAttribute(this.attrName) != null;\n            if (this.attrValue) {\n                found = found && this.elem.getAttribute(this.attrName) === this.attrValue;\n            }\n            const res = this.neg ^ found;\n            if (this.castTo === \"boolean\") {\n                return Boolean(res);\n            } else {\n                return res;\n            }\n        }\n        setValue(bool) {\n            if (this.neg ^ bool) {\n                this.elem.setAttribute(this.attrName, this.attrValue || '');\n            } else {\n                this.elem.removeAttribute(this.attrName);\n            }\n        }\n    },\n    \"attrRegex\": class {\n        constructor(elem, attr, castTo) {\n            this.elem = elem;\n            this.castTo = castTo;\n            const parts = attr.split(\"=\");\n            this.attrName = parts[0].trim();\n            if (parts.length > 1) {\n                this.attrValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n        }\n        getValue() {\n            let found = this.elem.getAttribute(this.attrName) != null;\n            if (found) {\n                const match = this.elem.getAttribute(this.attrName).match(this.attrValue);\n                if (match?.[1] && typeof (match[1]) === \"string\") {\n                    return performCasting(match[1], this.castTo);\n                }\n                return '';\n            }\n            return null;\n        }\n        setValue(val) {\n            this.elem.setAttribute(this.attrName, this.attrValue.replace(\"(.*)\", val + \"\"));\n        }\n    },\n    \"hasStyle\": class {\n        constructor(elem, attr, castTo, neg) {\n            this.elem = elem;\n            this.castTo = castTo;\n            this.neg = neg;\n            const parts = attr.split(\":\");\n            this.styName = parts[0].trim();\n            if (parts.length > 1) {\n                this.styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n        }\n        getValue() {\n            const st = this.elem.style;\n            const has = st.getPropertyValue(this.styName) === this.styValue;\n            const res = has ^ this.neg;\n            if (this.castTo === \"boolean\") {\n                return Boolean(res);\n            } else {\n                return res;\n            }\n        }\n        setValue(bool) {\n            if (bool ^ this.neg) {\n                this.elem.style.setProperty(this.styName, this.styValue);\n            } else {\n                this.elem.style.removeProperty(this.styName);\n            }\n        }\n    },\n    \"styleRegex\": class {\n        constructor(elem, attr, castTo) {\n            this.elem = elem;\n            this.castTo = castTo;\n            const parts = attr.split(\":\");\n            this.styName = parts[0].trim();\n            if (parts.length > 1) {\n                this.styValue = parts[1].replace(/[\"']/g, '').trim();\n            }\n        }\n        getValue() {\n            const st = this.elem.style;\n            const has = st.getPropertyValue(this.styName) != null;\n            if (has) {\n                const match = st.getPropertyValue(this.styName).match(this.styValue);\n                if (match?.[1] && (typeof match[1]) === \"string\") {\n                    return performCasting(match[1], this.castTo);\n                }\n                return '';\n            }\n            return null;\n        }\n        setValue(val) {\n            this.elem.style.setProperty(this.styName, this.styValue.replace(\"(.*)\", val + \"\"));\n        }\n    }\n};\n\n/**\n * @param {string} definition\n * @param {HTMLElement} elem  - The root of widget\n * @param {string} castTo  - The type that must be returned\n * @returns {BindingFactory}\n */\nexport const parseBinding = (definition, elem, castTo) => {\n    if (!definition || !elem) {\n        return null;\n    }\n    const regex = /^\\s*(?:<([^<>]+)>)?\\s*(not\\s+)?(classRegex|hasClass|styleRegex|hasStyle|attr|attrRegex|hasAttr)\\s+<([^<>]+)>\\s*$/g;\n    const m = regex.exec(definition);\n    if (m) {\n        if (m[1]) {\n            // Rule applied to a child of the main widget node\n            elem = elem.querySelector(m[1]);\n        }\n        const neg = m[2] !== undefined;\n        const type = m[3];\n        const params = m[4];\n        return new BindingFactory[type](elem, params, castTo, neg);\n    }\n    return null;\n};\n\n/**\n * Capitalizes the first letter of a string\n * @param {string | undefined | null} s\n * @returns {string}\n */\nexport const capitalize = s => (s && s[0].toUpperCase() + s.slice(1)) || \"\";"],"names":["Ejs","base","url","trim","toLowerCase","startsWith","pathJoin","id","onSuccess","onError","document","head","querySelector","newScript","createElement","type","src","setAttribute","onload","console","info","onerror","error","append","editor","widgetTemplate","silent","mergevars","translations","key","component","userWidgetFilter","createFilterFunction","notificationManager","open","text","timeout","handleFilterResult","res","out","msg","setContent","initialHTML","getContent","filteredResult","dom","window","then","name","replace","str","def","Math","floor","match","val","parseInt","isNaN","ex","varname","listVars","found","len","length","k","s","h","l","i","charCodeAt","abs","str1","needle","indexOf","transformStr","Builder","Shared","currentScope","_document$querySelect","activatePopup","globalConfig","genID","random","toString","substring","scopedEval","ctx","expr","listArgs","listVals","Object","keys","forEach","push","Function","evaluator","defineVar","ctx2","pos","varvalue","templateRendererMustache","template","context","render","condition","dict","components","split","dim","maxValues","Array","loopVars","total","cc","parts","unshift","String","fromCharCode","cname","dm","output","_ei","Mustache","incrUp","currentDim","oldValue","newValue","join","loopvar","maxIter","applyMustacheHelpers","templateRendererEJS","I18n","lang","wordKey","Promise","resolve","reject","require","ejsModule","templateRenderer","engine","includes","tmpl","constructor","snpt","partials","parameters","param","partial","value","options","_snpt","this","category","insertquery","selectors","unpack","requires","isArray","stars","version","instructions","_instructionsParsed","decodeURIComponent","defaults","obj","defaultsCopy","toInterpolate","assign","isFor","userId","hidden","grantStr","for","allowMode","grantList","isUsableInScope","scope","widgetScopes","RegExp","exec","isFilter","hasBindings","filter","undefined","bind","UserStorage","courseId","_instances","_userId","_courseId","STORE_KEY","_localStore","valors","_sessionStore","searchtext","loadStore","localStorage","txt","getItem","JSON","parse","sessionStorage","txt2","getFromLocal","defaultValue","MLSC","MLS","getFromSession","saveStore","setItem","stringify","setToLocal","persist","theValueMap","theKey","setToSession","Transformers","toUpperCase","r","encodeURIComponent","transSeq","j","lenj","prts","transfunc","reduce","filterCode","a","b","endsWith","performCasting","BindingFactory","elem","className","castTo","neg","getValue","classList","contains","Boolean","setValue","bool","add","remove","classExpr","ret","c","cl","attrName","getAttribute","attr","attrValue","removeAttribute","styName","styValue","style","getPropertyValue","setProperty","removeProperty","st","definition","m","params","slice"],"mappings":"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"}