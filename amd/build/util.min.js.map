{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/* eslint-disable no-console */\n/* eslint-disable no-eq-null */\n/* eslint-disable no-bitwise */\n/* eslint-disable no-new-func */\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny WidgetHub plugin.\n *\n * @module      tiny_widgethub/plugin\n * @copyright   2024 Josep Mulet Pol <pep.mulet@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport jQuery from 'jquery';\n\n/**\n * @returns {string} a randomID\n */\nexport function genID() {\n    return 'g' + Math.random().toString(32).substring(2);\n}\n\n/**\n * @param {Object.<string, any>} ctx\n * @param {string} expr\n * @param {boolean=} keepFns - Keep or not the funcions in the ctx\n * @returns {any} The evaluated expression within the context ctx\n */\nexport function evalInContext(ctx, expr, keepFns) {\n    const listArgs = [];\n    const listVals = [];\n\n    if (ctx) {\n        Object.keys(ctx).forEach((key) => {\n            // Remove functions from ctx\n            if (keepFns || typeof ctx[key] !== \"function\") {\n                listArgs.push(key);\n                listVals.push(ctx[key]);\n            }\n        });\n    }\n    listArgs.push('expr');\n    listArgs.push('return eval(expr)');\n    listVals.push(expr);\n    const evaluator = new Function(...listArgs);\n    return evaluator(...listVals);\n}\n\n/**\n * @param {string} s - string to the hashed\n * @returns {number}\n */\nexport function hashCode(s) {\n    s = s || \"\";\n    let h = 0;\n    const l = s.length;\n    let i = 0;\n    if (l > 0) {\n        while (i < l) {\n            h = (h << 6) + ((s.charCodeAt(i) - 65) | 0);\n            i++;\n        }\n    }\n    return Math.abs(h);\n}\n\n/**\n * @param {string} str1\n * @param {string} needle\n * @returns {boolean} Whether str1 contains needle or not\n */\nexport function searchComp(str1, needle) {\n    str1 = (str1 || '').trim().toLowerCase();\n    needle = (needle || '').trim().toLowerCase();\n    str1 = str1.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    needle = needle.replace(/[àáâãäå]/, \"a\")\n        .replace(/[èéêë]/, \"e\")\n        .replace(/[ìíîï]/, \"i\")\n        .replace(/[òóôö]/, \"o\")\n        .replace(/[ùúüû]/, \"u\")\n        .replace(/ç/, \"c\")\n        .replace(/·/, \"\");\n    return str1.indexOf(needle) >= 0;\n}\n\n/** Default transformers */\nconst Transformers = {\n    /** @param {string} txt */\n    toUpperCase: function(txt) {\n        return (txt + \"\").toUpperCase();\n    },\n    /** @param {string} txt */\n    toLowerCase: function(txt) {\n        return (txt + \"\").toLowerCase();\n    },\n   /** @param {string} txt */\n    trim: function(txt) {\n        return (txt + \"\").trim();\n    },\n    /** @param {string} txt */\n    ytId: function(txt) {\n        // Finds the youtubeId in a text\n        const rx = /^.*(?:(?:youtu\\.be\\/|v\\/|vi\\/|u\\/\\w\\/|embed\\/|shorts\\/)|(?:(?:watch)?\\?v(?:i)?=|&v(?:i)?=))([^#&?]*).*/;\n        const r = (txt || '').match(rx);\n        if (r?.length) {\n            return r[1];\n        }\n        return txt;\n    },\n    /** @param {string} txt */\n    vimeoId: function(txt) {\n        const regExp = /^.*(vimeo\\.com\\/)((channels\\/[A-z]+\\/)|(groups\\/[A-z]+\\/videos\\/))?(\\d+)/;\n        const match = new RegExp(regExp).exec(txt || \"\");\n        if (match?.[5]) {\n            return match[5];\n        }\n        return txt;\n    },\n    /** @param {string} txt */\n    serveGDrive: function(txt) {\n        // Expecting https://drive.google.com/file/d/1DDUzcFrOlzWb3CBdFPJ1NCNXClvPbm5B/preview\n        const res = (txt + \"\").match(/https:\\/\\/drive.google.com\\/file\\/d\\/([a-zA-Z0-9_]+)\\//);\n        if (res?.length) {\n            const driveId = res[1];\n            return \"https://docs.google.com/uc?export=open&id=\" + driveId;\n        }\n        return txt;\n    },\n    /** @param {string} txt */\n    removeHTML: function(txt) {\n        return (txt || '').replace(/<[^>]*>?/gm, '');\n    },\n    /** @param {string} txt */\n    escapeHTML: function(txt) {\n        return (txt || '').replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#039;\");\n    },\n   /** @param {string} txt */\n    encodeHTML: function(txt) {\n        // @ts-ignore\n        return encodeURIComponent(txt || \"\");\n    },\n    /** @param {string} txt */\n    escapeQuotes: function(txt) {\n        return (txt || '').replace(/\"/gm, \"'\");\n    }\n};\n\n\nclass Builder {\n    transSeq;\n    // @ts-ignore\n    constructor(transformStr) {\n        const parts = transformStr.split('|');\n        this.transSeq = [];\n        for (let j = 0, lenj = parts.length; j < lenj; j++) {\n            const prts = parts[j].trim();\n            // @ts-ignore\n            const transfunc = Transformers[prts];\n            if (transfunc != null) {\n                this.transSeq.push(transfunc);\n            } else {\n                console.error(\"Cannot find transformer named \" + prts);\n            }\n        }\n    }\n\n    // @ts-ignore\n    reduce(text) {\n        for (let j = 0, lenj = this.transSeq.length; j < lenj; j++) {\n            const transfunc = this.transSeq[j];\n            text = transfunc(text);\n        }\n        return text;\n    }\n}\n\n/**\n * @param {string} transformStr\n * @returns {Builder} call reduce(text) function\n */\nexport function stream(transformStr) {\n    return new Builder(transformStr);\n}\n\n/**\n * @param {string} name\n * @returns {string} Replaces $ apperences by _ to make the name compatible by data attributes\n */\nexport function cleanParameterName(name) {\n    return name.replace(/\\$/g, '_');\n}\n\n/**\n * Creates a filter funcion from filterCode\n * @param {string} filterCode\n * @returns {Function?}\n */\nexport function createFilterFunction(filterCode) {\n    let userWidgetFilter = null;\n    try {\n        userWidgetFilter = new Function('text', 'editor', 'opts', filterCode);\n    } catch (ex) {\n        userWidgetFilter = null;\n        console.error(ex);\n    }\n    return userWidgetFilter;\n}\n\n/**\n * @param {import('./plugin').TinyMCE} editor\n * @param {{get_strings: (keyComponent: any[]) => Promise<string[]>}} coreStr - dependency on core/str\n * @returns {*}\n */\nexport function applyWidgetFilterFactory(editor, coreStr) {\n    /**\n     * @param {string} widgetTemplate\n     * @param {boolean} silent\n     * @param {object?} mergevars\n     * @returns {Promise<boolean>} - True if the filter can be compiled\n     */\n    return async(widgetTemplate, silent, mergevars) => {\n        const translations = await coreStr.get_strings([\n            {key: 'filterres', component: 'tiny_widgethub'},\n            {key: 'nochanges', component: 'tiny_widgethub'}\n        ]);\n        // Es tracta d'un filtre, no d'un widget i s'ha de tractar de forma diferent\n        const userWidgetFilter = createFilterFunction(widgetTemplate);\n\n        if (!userWidgetFilter) {\n            editor.notificationManager.open({\n                text: translations[0] + \": Invalid filter\",\n                type: 'danger',\n                timeout: 4000\n            });\n            return false;\n        }\n        // @ts-ignore\n        const handleFilterResult = function(res) {\n            const out = res[0];\n            let msg = res[1];\n            if (out != null) {\n                if (typeof out === \"string\") {\n                    editor.setContent(out);\n                    editor.notificationManager.open({\n                        text: translations[0] + \": \" + msg,\n                        type: 'success',\n                        timeout: 5000\n                    });\n                } else if (out === true) {\n                    editor.notificationManager.open({\n                        text: translations[0] + \": \" + msg,\n                        type: 'success',\n                        timeout: 5000\n                    });\n                } else if (out === false && !silent) {\n                    editor.notificationManager.open({\n                        text: translations[1],\n                        type: 'info',\n                        timeout: 5000\n                    });\n                }\n            } else if (!silent) {\n                editor.notificationManager.open({\n                    text: translations[1],\n                    type: 'info',\n                    timeout: 5000\n                });\n            }\n        };\n\n        const initialHTML = editor.getContent();\n        const filteredResult = userWidgetFilter(initialHTML, editor, mergevars);\n        // Hi ha la possibilitat que el filtre retorni una promesa o un array\n        const isPromise = filteredResult != null && typeof (filteredResult) === 'object' && ('then' in filteredResult);\n        if (isPromise) {\n            filteredResult.then(handleFilterResult).catch((/** @type {any} */ err) => console.error(err));\n        } else {\n            handleFilterResult(filteredResult || [null, translations[1]]);\n        }\n        return true;\n    };\n}\n\n/**\n * Safe conversion of a string to integer by handling errors and NaN values\n * In this case, the def number passed is returned\n * @param {string | undefined | null | number} str\n * @param {number} def - default value\n * @returns {number}\n */\nexport function convertInt(str, def) {\n    if (str && typeof str === 'number') {\n        return Math.floor(str);\n    }\n    if (!str || !(str + \"\").trim() || !RegExp(/^\\s*[+-]?\\d+(\\.\\d*)?\\s*$/).exec(str + \"\")) {\n        return def;\n    }\n    try {\n        const val = parseInt(str + \"\");\n        if (!isNaN(val)) {\n            return val;\n        }\n    } catch (ex) {\n        // Pass\n    }\n    return def;\n}\n\n/**\n * Finds the parameter with a given name within the list of objects\n * @param {string} varname\n * @param {import('./options').Param[]} listVars\n * @returns {import('./options').Param | null}\n */\nexport function findVariableByName(varname, listVars) {\n    if (!listVars) {\n        return null;\n    }\n    let found = null;\n    const len = listVars.length;\n    let k = 0;\n    while (k < len && !found) {\n        if (listVars[k].name === varname) {\n            found = listVars[k];\n        }\n        k++;\n    }\n    return found;\n}\n\n/**\n * Safely joins two parts of an url\n * @param {string} a\n * @param {string=} b\n * @returns {string}\n */\nexport function pathJoin(a, b) {\n    a = (a || \"\").trim();\n    b = (b || \"\").trim();\n    if (!a.endsWith('/')) {\n        a = a + '/';\n    }\n    if (b.startsWith('/')) {\n        b = b.substring(1);\n    }\n    return a + b;\n}\n\n/**\n * Adds the baseurl if the passed url does not start with http or https\n * @param {string} base\n * @param {string=} url\n * @returns {string}\n */\nexport function addBaseToUrl(base, url) {\n    url = (url || \"\").trim();\n    if (url.toLowerCase().startsWith(\"http\")) {\n        return url;\n    }\n    // Afegir la base\n    const out = pathJoin(base, url);\n    return out;\n}\n\n/**\n * @param {*} value\n * @param {string | undefined} type\n * @returns {*}\n */\nexport const performCasting = function(value, type) {\n    if (!type || typeof value === type) {\n        return value;\n    }\n    switch (type) {\n        case (\"boolean\"):\n            if (value === 1 || value === \"1\" || value === true || value === \"true\") {\n                value = true;\n            } else {\n                value = false;\n            }\n            break;\n        case (\"number\"):\n            try {\n                let parsed;\n                if ((value + '').indexOf(\".\") < 0) {\n                    parsed = parseInt(value);\n                } else {\n                    parsed = parseFloat(value);\n                }\n                if (!isNaN(parsed)) {\n                    value = parsed;\n                } else {\n                    value = 0;\n                    console.error(`Error parsing number ${value}`);\n                }\n            } catch (ex) {\n                value = 0;\n                console.error(`Error parsing number ${value}`);\n            }\n            break;\n        case (\"string\"):\n            if (typeof value === 'object') {\n                value = JSON.stringify(value);\n            } else {\n                value = value + \"\";\n            }\n            break;\n        default:\n            console.error(`Fail to cast ${value} to ${type}`);\n    }\n    return value;\n};\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n */\nconst xor = function(a, b) {\n    return !a !== !b;\n};\n\n/**\n * @param {string} str\n * @param {*} match\n * @param {string} replacement\n * @returns {string}\n */\nconst replaceStrPart = function(str, match, replacement) {\n    if (!match.indices) {\n        console.error(\"RegExp match does not include indices\");\n        return str;\n    }\n    const [a, b] = match.indices[1];\n    return str.substring(0, a) + replacement + str.substring(b);\n};\n\n/**\n * Replaces the first capturing group in regexExpr by replacement,\n * The remaining capturing groups are removed.\n * @param {string} regexExpr\n * @param {string} replacement\n * @returns {string}\n */\nconst getValueFromRegex = function(regexExpr, replacement) {\n    const reParser = /\\((?!\\?:).*?\\)/g;\n    let capturingGroupCount = 0;\n    return regexExpr.replace(reParser, () => {\n        capturingGroupCount++;\n        if (capturingGroupCount === 1) {\n            return replacement + '';\n        }\n        return \"\"; // Remove all other capturing groups\n    });\n};\n\n/**\n * @param {Element} el - The target element\n * @returns\n */\nconst bindingFactory = function(el) {\n    /** @this {Record<string, Function>} */\n    const methods = {\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasClass: (className, query, neg) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                // @ts-ignore\n                getValue: () => {\n                    const res = xor(neg, elem?.classList?.contains(className));\n                    return Boolean(res);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.classList.add(className);\n                    } else {\n                        elem?.classList.remove(className);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} className\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasClass: (className, query) => {\n            return methods.hasClass(className, query, true);\n        },\n        /**\n         * @param {string} classExpr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        classRegex: (classExpr, query, castTo) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    let ret = '';\n                    const classes = Array.from(elem?.classList ?? []);\n                    for (const clazz of classes) {\n                        const match = new RegExp(classExpr).exec(clazz);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            ret = match[1];\n                            break;\n                        }\n                    }\n                    return performCasting(ret, castTo);\n                },\n                setValue: (val) => {\n                    const cl = Array.from(elem?.classList ?? []);\n                    let found = false;\n                    cl.forEach(c => {\n                        const match = new RegExp(classExpr, 'd').exec(c);\n                        if (match === null) {\n                            return;\n                        }\n                        found = true;\n                        elem?.classList.remove(c);\n                        const newCls = replaceStrPart(c, match, val + '');\n                        elem?.classList.add(newCls);\n                    });\n                    // If not found, then set the regExp replacing the\n                    // first capturing group with val, and removing the remaining groups.\n                    if (!found) {\n                        const newCls = getValueFromRegex(classExpr, val + '');\n                        elem?.classList.add(newCls);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attrName\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        attr: (attrName, query, castTo) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    let attrValue = elem?.getAttribute(attrName);\n                    if (attrName.indexOf('-bs-') > 0) {\n                        attrValue = attrValue ?? elem?.getAttribute(attrName.replace('-bs-', '-'));\n                    }\n                    return performCasting(attrValue, castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    const attrVal = val + '';\n                    elem?.setAttribute(attrName, attrVal);\n                    if (attrName.indexOf('-bs-') > 0) {\n                        // Save as old bs\n                        elem?.setAttribute(attrName.replace('-bs-', '-'), attrVal);\n                    }\n                    if (attrName === 'href' || attrName === 'src') {\n                        elem?.setAttribute('data-mce-' + attrName, attrVal);\n                    }\n                }\n            };\n        },\n        /**\n         * Adapted to take into account both data- and data-bs- for Boostrap 4 & 5 compatibility.\n         * @param {string} attrName - Name without data- nor data-bs-\n         * @param {string=} query\n         * @param {string=} castTo\n         * @param {number=} version - 4 or 5 depending the version of BS currently using\n         * @returns {Binding}\n         */\n        attrBS: (attrName, query, castTo, version) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            return {\n                getValue: () => {\n                    // If version=4 it has preference BS4 over BS5, it will not remove BS4 prefix\n                    let p1 = '';\n                    let p2 = 'bs-';\n                    if (version === 5) {\n                        p1 = p2;\n                        p2 = '';\n                    }\n                    let value = elem?.getAttribute('data-' + p1 + attrName);\n                    if (value === undefined) {\n                        value = elem?.getAttribute('data-' + p2 + attrName);\n                    }\n                    return performCasting(value || '', castTo);\n                },\n                // @ts-ignore\n                setValue: (val) => {\n                    if (typeof val === \"boolean\") {\n                        val = val ? 1 : 0;\n                    }\n                    const attrVal = val + '';\n                    elem?.setAttribute('data-bs-' + attrName, attrVal);\n                    if (version === 5) {\n                        elem?.removeAttribute('data-' + attrName);\n                    } else {\n                        elem?.setAttribute('data-' + attrName, attrVal);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasAttr: (attr, query, neg) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            return {\n                getValue: () => {\n                    let found = elem?.getAttribute(attrName) != null;\n                    if (attrValue) {\n                        found = found && elem?.getAttribute(attrName) === attrValue;\n                    }\n                    return xor(neg, found);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.setAttribute(attrName, attrValue || '');\n                        if (attrName === 'href' || attrName === 'src') {\n                            elem?.setAttribute('data-mce-' + attrName, attrValue + '');\n                        }\n                    } else {\n                        elem?.removeAttribute(attrName);\n                        if (attrName === 'href' || attrName === 'src') {\n                            elem?.removeAttribute('data-mce-' + attrName);\n                        }\n                    }\n                }\n            };\n        },\n        /**\n         * Variant to check for compatibility between Bootstrap 4 and 5.\n         * @param {string} attr - attr name without data- nor data-bs-\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @param {number=} version - 4 or 5\n         * @returns {Binding}\n         */\n        hasAttrBS: (attr, query, neg, version) => {\n            /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            const getValuePrefix = (/** @type{string} **/ prefix) => {\n                let found = elem?.getAttribute(prefix + attrName) != null;\n                if (attrValue) {\n                    found = found && elem?.getAttribute(prefix + attrName) === attrValue;\n                }\n                return xor(neg, found);\n            };\n            return {\n                getValue: () => {\n                    let p1 = 'data-';\n                    let p2 = 'data-bs-';\n                    if (version === 5) {\n                        p2 = p1;\n                        p1 = 'data-bs-';\n                    }\n                    return getValuePrefix(p1) || getValuePrefix(p2);\n                },\n                // @ts-ignore\n                setValue: (bool) => {\n                    if (xor(neg, bool)) {\n                        elem?.setAttribute('data-bs-' + attrName, attrValue || '');\n                        if (version === 5) {\n                            elem?.removeAttribute('data-' + attrName);\n                        } else {\n                            elem?.setAttribute('data-' + attrName, attrValue || '');\n                        }\n                    } else {\n                        elem?.removeAttribute('data-' + attrName);\n                        elem?.removeAttribute('data-bs-' + attrName);\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} attr\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasAttr: (attr, query) => {\n            return methods.hasAttr(attr, query, true);\n        },\n        /**\n         * @param {string} attr - Regex of attr\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        attrRegex: function(attr, query, castTo) {\n             /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\"=\");\n            const attrName = parts[0].trim();\n            let attrValue = '';\n            if (parts.length > 1) {\n                attrValue = parts[1].trim();\n            }\n            return {\n                getValue() {\n                    const found = elem?.getAttribute(attrName) != null;\n                    if (found) {\n                        const match = elem?.getAttribute(attrName)?.match(attrValue);\n                        if (match?.[1] && typeof (match[1]) === \"string\") {\n                            return performCasting(match[1], castTo);\n                        }\n                        return '';\n                    }\n                    return null;\n                },\n                setValue(val) {\n                    const oldValue = elem?.getAttribute(attrName) ?? '';\n                    const match = new RegExp(attrValue, 'd').exec(oldValue);\n                    let newValue;\n                    if (match) {\n                        newValue = replaceStrPart(oldValue, match, val + '');\n                    } else {\n                        newValue = getValueFromRegex(attrValue, val + '');\n                    }\n                    elem?.setAttribute(attrName, newValue);\n                    if (attrName === 'href' || attrName === 'src') {\n                        elem?.setAttribute('data-mce-' + attrName, newValue + '');\n                    }\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @param {boolean=} neg\n         * @returns {Binding}\n         */\n        hasStyle: function(sty, query, neg) {\n             /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = sty.split(\":\");\n            let styName = parts[0].trim();\n            /** @type {string | undefined} */\n            let styValue;\n            if (parts.length > 1) {\n                styValue = parts[1].trim();\n            }\n            return {\n                getValue() {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    const pValue = st.getPropertyValue(styName);\n                    const has = styValue === undefined ? pValue !== '' : pValue === styValue;\n                    return xor(has, neg);\n                },\n                // @ts-ignore\n                setValue(bool) {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    if (xor(bool, neg)) {\n                        st?.setProperty(styName, styValue ?? '');\n                    } else {\n                        st?.removeProperty(styName);\n                    }\n                    // TODO: better way to update data-mce-style\n                    elem?.setAttribute('data-mce-style', st?.cssText ?? '');\n                }\n            };\n        },\n        /**\n         * @param {string} sty\n         * @param {string=} query\n         * @returns {Binding}\n         */\n        notHasStyle: (sty, query) => {\n            return methods.hasStyle(sty, query, true);\n        },\n        /**\n         * @param {string} attr - styName:styValue where styValue is a regex with (.*)\n         * @param {string=} query\n         * @param {string=} castTo\n         * @returns {Binding}\n         */\n        styleRegex: function(attr, query, castTo) {\n             /** @type {Element | null} */\n            let elem = el;\n            if (query) {\n                elem = el.querySelector(query);\n            }\n            const parts = attr.split(\":\");\n            const styName = parts[0].trim();\n            let styValue = '';\n            if (parts.length > 1) {\n                styValue = parts[1].trim();\n            }\n            return {\n                /** @returns {string | null} */\n                getValue() {\n                    // @ts-ignore\n                    const st = elem?.style;\n                    const currentVal = st?.getPropertyValue(styName);\n                    if (currentVal) {\n                        if (styValue) {\n                            const match = new RegExp(styValue).exec(currentVal);\n                            if (match?.[1] && (typeof match[1]) === \"string\") {\n                                return performCasting(match[1], castTo);\n                            }\n                        } else {\n                            return performCasting(currentVal, castTo);\n                        }\n                    }\n                    return performCasting('', castTo);\n                },\n                // @ts-ignore\n                setValue(val) {\n                    let newValue;\n                    // @ts-ignore\n                    const st = elem?.style;\n                    if (styValue) {\n                        // Case val <= 0 && styName contains width or height\n                        if ((styName.includes(\"width\") || styName.includes(\"height\")) && (parseFloat(val + '') <= 0)) {\n                            newValue = '';\n                        } else {\n                            const oldValue = st?.getPropertyValue(styName) ?? '';\n                            if (oldValue) {\n                                const match = new RegExp(styValue, 'd').exec(oldValue);\n                                // @ts-ignore\n                                newValue = replaceStrPart(oldValue, match, val + '');\n                            } else {\n                                newValue = styValue.replace('(.*)', val + '');\n                            }\n                        }\n                    } else {\n                        newValue = val + '';\n                    }\n                    st?.setProperty(styName, newValue);\n                    // TODO: better way to update data-mce-style\n                    elem?.setAttribute('data-mce-style', st?.cssText || '');\n                }\n            };\n        }\n    };\n    return methods;\n};\n\n/**\n * @typedef {Object} Binding\n * @property {() => unknown} getValue\n * @property {(value: string | boolean | number) => void} setValue\n */\n/**\n * @param {string | {get?: string, set?: string, getValue?: string, setValue?: string}} definition\n * @param {Element} elem  - The root of widget\n * @param {string=} castTo  - The type that must be returned\n * @returns {Binding | null}\n */\nexport const createBinding = (definition, elem, castTo) => {\n    /** @type {Binding | null} */\n    let bindFn = null;\n    if (typeof (definition) === 'string') {\n        return evalInContext({...bindingFactory(elem)}, definition, true);\n    } else {\n        // The user provides the get and set functions (for jQuery element) @deprecated\n        // or getValue, setValue (for vanilla JS elements)\n        bindFn = {\n            getValue: () => {\n                let v;\n                if (definition.getValue) {\n                    v = evalInContext({elem}, `(${definition.getValue})(elem)`);\n                } else if (definition.get) {\n                    // @Deprecated. It will be removed in the future.\n                    v = evalInContext({elem: jQuery(elem)}, `(${definition.get})(elem)`);\n                }\n                if (castTo) {\n                    v = performCasting(v, castTo);\n                }\n                return v;\n            },\n            setValue: (v) => {\n                if (definition.setValue) {\n                    evalInContext({elem, v}, `(${definition.setValue})(elem, v)`);\n                } else if (definition.set) {\n                    // @Deprecated. It will be removed in the future.\n                    evalInContext({elem: jQuery(elem), v}, `(${definition.set})(elem, v)`);\n                }\n            }\n        };\n    }\n    return bindFn;\n};\n\n/**\n * Capitalizes the first letter of a string\n * @param {string | undefined | null} s\n * @returns {string}\n */\nexport const capitalize = s => (s && s[0].toUpperCase() + s.slice(1)) || \"\";\n\n/**\n * @param {string | null | undefined} color - color in hex or rgb or rgba\n * @returns {[string, number]} - The color in hex format, alpha channel 0..1\n */\nexport function toHexAlphaColor(color) {\n    color = (color || '#000000').trim().toLowerCase();\n    let alpha = 1;\n    if (color.startsWith(\"#\") && color.length === 9) {\n        // Already in hex & alpha\n        alpha = parseInt('0x' + color.substring(7)) / 255.0;\n        color = color.substring(0, 7);\n    } else if (color.startsWith('rgb')) {\n        // Assume rgb or rgba\n        const sep = color.indexOf(\",\") > -1 ? \",\" : \" \";\n        const a = color.replace(/[^\\d,]/g, \"\").split(sep);\n        color = \"#\" + ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + (+a[2])).toString(16).slice(1);\n        // Is rgba?\n        if (a.length === 4) {\n            alpha = +a[3];\n            if (alpha > 1) {\n                alpha = 0.01 * alpha;\n            }\n        }\n    }\n    return [color, alpha];\n}\n\n/**\n * @param {string | null | undefined} hex - color in hex\n * @param {number} alpha - 0..1 or 0..100\n * @returns {string} - The color in rgba syntax\n */\nexport function toRgba(hex, alpha) {\n    hex = (hex || '#000000').trim().toLowerCase();\n    /** @type {number | string} */\n    let alpha2 = alpha ?? 1;\n    if (alpha2 > 1) {\n        alpha2 *= 0.01;\n    }\n    if (alpha2 !== 0 && alpha2 !== 1) {\n        alpha2 = alpha2.toFixed(2);\n    }\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})/i.exec(hex);\n    let r = 0,\n        g = 0,\n        b = 0;\n    if (result) {\n      r = parseInt(result[1], 16);\n      g = parseInt(result[2], 16);\n      b = parseInt(result[3], 16);\n    }\n    if (alpha === 1) {\n        return `rgb(${r},${g},${b})`;\n    }\n    return `rgba(${r},${g},${b},${alpha2})`;\n}\n\n/**\n * Simple debounce function\n * @param {(evt?: any) => void} cb\n * @param {number} [delay]\n */\n/**\n * Simple debounce function\n * @param {(...args: unknown[]) => void} cb\n * @param {number} [delay]\n * @returns {((...args: unknown[]) => void) & {clear: () => void}}\n */\nexport function debounce(cb, delay = 1000) {\n    /** @type{number | null} */\n    let timeoutId = null;\n    const debounced = (/** @type {unknown[]} */ ...args) => {\n        if (timeoutId) {\n            window.clearTimeout(timeoutId);\n        }\n        timeoutId = window.setTimeout(() => {\n          cb(...args);\n        }, delay);\n    };\n    debounced.clear = () => {\n        if (!timeoutId) {\n            return;\n        }\n        window.clearTimeout(timeoutId);\n        timeoutId = null;\n    };\n    return debounced;\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {...string} classNames\n */\nexport function toggleClass(elem, ...classNames) {\n    const classList = elem.classList;\n    classNames.forEach(name => {\n        if (classList.contains(name)) {\n            classList.remove(name);\n        } else {\n            classList.add(name);\n        }\n    });\n}\n\n/**\n * Normalize version string to [major, minor, patch]\n * @param {string} v\n * @returns {number[]}\n */\nfunction parseVersion(v) {\n    return v\n      .split('.')\n      .map(part => Number(part.trim()))\n      .concat([0, 0])\n      .slice(0, 3);\n}\n\n/**\n * Compares a version with a given condition.\n * @param {string} current - The current version to compare against condition in major.minor.revision format\n * @param {string | null | undefined} [condition] - The condition to meet. In <, <=, =, >=, major.minor.revision\n * @returns {boolean} True if current meets condition\n */\nexport function compareVersion(current, condition) {\n  if (!condition) {\n    return true;\n  }\n\n  // Parse condition string\n  const match = condition.trim().match(/^(>=|<=|>|<|=)?\\s*(\\d+(?:\\.\\d+){0,2})$/);\n  if (!match) {\n    console.error(\"Invalid version condition: \" + condition);\n    return true;\n  }\n\n  const operator = match[1] || \"=\";\n  const targetVersion = parseVersion(match[2]);\n  const currentVersion = parseVersion(current);\n\n  // Compare versions\n  let cmp = 0;\n  for (let i = 0; i < 3; i++) {\n    if (currentVersion[i] > targetVersion[i]) {\n      cmp = 1;\n      break;\n    }\n    if (currentVersion[i] < targetVersion[i]) {\n      cmp = -1;\n      break;\n    }\n  }\n\n  // Evaluate based on operator\n  switch (operator) {\n    case \">\": return cmp > 0;\n    case \">=\": return cmp >= 0;\n    case \"<\": return cmp < 0;\n    case \"<=\": return cmp <= 0;\n    case \"=\": return cmp === 0;\n    default:\n     console.log(\"Unknown operator: \" + operator);\n     return true;\n  }\n}\n\n/**\n * Parameters that are generated from $RND must never\n * be stored as recently used, nor used as new contexts\n * @param {Record<string, any>} ctx\n * @param {import('./options').Param[]} parameters\n * @returns {Record<string, any>}\n */\nexport function removeRndFromCtx(ctx, parameters) {\n    return Object.fromEntries(\n        Object.entries(ctx).filter(([k]) => {\n            const val = parameters.find(p => p.name === k)?.value;\n            return val !== '$RND';\n        })\n    );\n}\n\n/**\n * Convert an HTML string into DOM element(s)\n * @param {string} html - HTML string\n * @returns {HTMLElement} - Returns a single element if one root, or a DocumentFragment if multiple\n */\nexport function htmlToElement(html) {\n    const template = document.createElement('template');\n    template.innerHTML = html.trim();\n\n    if (template.content.childElementCount === 1) {\n        // @ts-ignore\n        return template.content.firstElementChild;\n    } else {\n        // If multiple root elements, return a fragment\n        // @ts-ignore\n        return template.content;\n    }\n}"],"names":["evalInContext","ctx","expr","keepFns","listArgs","listVals","Object","keys","forEach","key","push","Function","evaluator","base","url","trim","toLowerCase","startsWith","pathJoin","editor","coreStr","async","widgetTemplate","silent","mergevars","translations","get_strings","component","userWidgetFilter","createFilterFunction","notificationManager","open","text","type","timeout","handleFilterResult","res","out","msg","setContent","filteredResult","getContent","then","catch","err","console","error","name","replace","current","condition","match","operator","targetVersion","parseVersion","currentVersion","cmp","i","log","str","def","Math","floor","RegExp","exec","val","parseInt","isNaN","ex","cb","delay","timeoutId","debounced","args","window","clearTimeout","setTimeout","clear","varname","listVars","found","len","length","k","random","toString","substring","s","h","l","charCodeAt","abs","html","template","document","createElement","innerHTML","content","childElementCount","firstElementChild","parameters","fromEntries","entries","filter","_ref","find","p","_parameters$find","value","str1","needle","indexOf","transformStr","Builder","color","alpha","sep","a","split","slice","hex","alpha2","toFixed","result","r","g","b","elem","classList","classNames","contains","remove","add","Transformers","toUpperCase","txt","ytId","vimeoId","serveGDrive","removeHTML","escapeHTML","encodeHTML","encodeURIComponent","escapeQuotes","transSeq","constructor","parts","j","lenj","prts","transfunc","reduce","this","filterCode","endsWith","performCasting","parsed","parseFloat","JSON","stringify","xor","replaceStrPart","replacement","indices","getValueFromRegex","regexExpr","capturingGroupCount","bindingFactory","el","methods","hasClass","className","query","neg","querySelector","getValue","_elem","_elem$classList","Boolean","setValue","bool","notHasClass","classRegex","classExpr","castTo","ret","classes","Array","from","clazz","cl","c","newCls","attr","attrName","attrValue","_elem9","getAttribute","_elem10","attrVal","setAttribute","attrBS","version","p1","p2","_elem14","undefined","_elem15","removeAttribute","hasAttr","hasAttrBS","getValuePrefix","prefix","notHasAttr","attrRegex","_elem33","_elem33$getAttribute","oldValue","newValue","hasStyle","sty","styValue","styName","pValue","_elem37","style","getPropertyValue","st","_elem38","setProperty","removeProperty","cssText","notHasStyle","styleRegex","_elem40","currentVal","_elem41","includes","definition","bindFn","v","get","set","map","part","Number","concat"],"mappings":"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"}